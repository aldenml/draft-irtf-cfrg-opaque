



Network Working Group                                        H. Krawczyk
Internet-Draft                                       Algorand Foundation
Intended status: Informational                               D. Bourdrez
Expires: 4 December 2021                                                
                                                                 K. Lewi
                                                           Novi Research
                                                               C.A. Wood
                                                              Cloudflare
                                                             2 June 2021


                  The OPAQUE Asymmetric PAKE Protocol
                     draft-irtf-cfrg-opaque-latest

Abstract

   This document describes the OPAQUE protocol, a secure asymmetric
   password-authenticated key exchange (aPAKE) that supports mutual
   authentication in a client-server setting without reliance on PKI and
   with security against pre-computation attacks upon server compromise.
   In addition, the protocol provides forward secrecy and the ability to
   hide the password from the server, even during password registration.
   This document specifies the core OPAQUE protocol and one
   instantiation based on 3DH.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Source for this draft and an issue tracker can be found at
   https://github.com/cfrg/draft-irtf-cfrg-opaque.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 4 December 2021.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements Notation
     1.2.  Notation
   2.  Cryptographic Dependencies
   3.  Protocol Overview
   4.  Client Credential Storage
     4.1.  Envelope Structure
     4.2.  Envelope Creation and Recovery
     4.3.  Envelope Modes
       4.3.1.  Internal mode
       4.3.2.  External mode
   5.  Offline Registration
     5.1.  Registration Messages
       5.1.1.  Registration Functions
   6.  Online Authenticated Key Exchange
     6.1.  Credential Retrieval
       6.1.1.  Credential Retrieval Messages
       6.1.2.  Credential Retrieval Functions
     6.2.  AKE Protocol
       6.2.1.  Protocol Messages
       6.2.2.  Key Schedule Functions
       6.2.3.  External Client API
       6.2.4.  External Server API
   7.  Configurations
   8.  Security Considerations
     8.1.  Related Analysis
     8.2.  Identities
     8.3.  Envelope Encryption
     8.4.  Export Key Usage
     8.5.  Static Diffie-Hellman Oracles
     8.6.  Input Validation
     8.7.  OPRF Hardening
     8.8.  Preventing Client Enumeration
     8.9.  Password Salt and Storage Implications
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Acknowledgments
   Appendix B.  Alternate AKE Instantiations
     B.1.  HMQV Instantiation Sketch
     B.2.  SIGMA-I Instantiation Sketch
   Appendix C.  Test Vectors
     C.1.  OPAQUE-3DH Test Vector 1
       C.1.1.  Configuration
       C.1.2.  Input Values
       C.1.3.  Intermediate Values
       C.1.4.  Output Values
     C.2.  OPAQUE-3DH Test Vector 2
       C.2.1.  Configuration
       C.2.2.  Input Values
       C.2.3.  Intermediate Values
       C.2.4.  Output Values
     C.3.  OPAQUE-3DH Test Vector 3
       C.3.1.  Configuration
       C.3.2.  Input Values
       C.3.3.  Intermediate Values
       C.3.4.  Output Values
     C.4.  OPAQUE-3DH Test Vector 4
       C.4.1.  Configuration
       C.4.2.  Input Values
       C.4.3.  Intermediate Values
       C.4.4.  Output Values
     C.5.  OPAQUE-3DH Test Vector 5
       C.5.1.  Configuration
       C.5.2.  Input Values
       C.5.3.  Intermediate Values
       C.5.4.  Output Values
     C.6.  OPAQUE-3DH Test Vector 6
       C.6.1.  Configuration
       C.6.2.  Input Values
       C.6.3.  Intermediate Values
       C.6.4.  Output Values
     C.7.  OPAQUE-3DH Test Vector 7
       C.7.1.  Configuration
       C.7.2.  Input Values
       C.7.3.  Intermediate Values
       C.7.4.  Output Values
     C.8.  OPAQUE-3DH Test Vector 8
       C.8.1.  Configuration
       C.8.2.  Input Values
       C.8.3.  Intermediate Values
       C.8.4.  Output Values
   Authors' Addresses

1.  Introduction

   Password authentication is ubiquitous in many applications.  In a
   common implementation, a client authenticates to a server by sending
   its client ID and password to the server over a secure connection.
   This makes the password vulnerable to server mishandling, including
   accidentally logging the password or storing it in plaintext in a
   database.  Server compromise resulting in access to these plaintext
   passwords is not an uncommon security incident, even among security-
   conscious companies.  Moreover, plaintext password authentication
   over secure channels like TLS is also vulnerable to cases where TLS
   may fail, including PKI attacks, certificate mishandling, termination
   outside the security perimeter, visibility to middleboxes, and more.

   Asymmetric (or Augmented) Password Authenticated Key Exchange (aPAKE)
   protocols are designed to provide password authentication and
   mutually authenticated key exchange in a client-server setting
   without relying on PKI (except during client/password registration)
   and without disclosing passwords to servers or other entities other
   than the client machine.  A secure aPAKE should provide the best
   possible security for a password protocol.  Namely, it should only be
   open to inevitable attacks, such as online impersonation attempts
   with guessed client passwords and offline dictionary attacks upon the
   compromise of a server and leakage of its credential file.  In the
   latter case, the attacker learns a mapping of a client's password
   under a one-way function and uses such a mapping to validate
   potential guesses for the password.  Crucially important is for the
   password protocol to use an unpredictable one-way mapping.
   Otherwise, the attacker can pre-compute a deterministic list of
   mapped passwords leading to almost instantaneous leakage of passwords
   upon server compromise.

   Despite the existence of multiple designs for (PKI-free) aPAKE
   protocols, none of these protocols are secure against pre-computation
   attacks.  In particular, none of these protocols can use the standard
   technique against pre-computation that combines _secret_ random
   values ("salt") into the one-way password mappings.  Either these
   protocols do not use a salt at all or, if they do, they transmit the
   salt from server to client in the clear, hence losing the secrecy of
   the salt and its defense against pre-computation.  Furthermore,
   transmitting the salt may require additional protocol messages.

   This document describes OPAQUE, a PKI-free secure aPAKE that is
   secure against pre-computation attacks.  OPAQUE provides forward
   secrecy (essential for protecting past communications in case of
   password leakage) and the ability to hide the password from the
   server, even during password registration.  Furthermore, OPAQUE
   enjoys good performance and an array of additional features including
   the ability to increase the difficulty of offline dictionary attacks
   via iterated hashing or other hardening schemes, and offloading these
   operations to the client (that also helps against online guessing
   attacks); extensibility of the protocol to support storage and
   retrieval of client secrets solely based on a password; being
   amenable to a multi-server distributed implementation where offline
   dictionary attacks are not possible without breaking into a threshold
   of servers (such a distributed solution requires no change or
   awareness on the client-side relative to a single-server
   implementation).

   OPAQUE is defined and proven as the composition of two
   functionalities: an oblivious pseudorandom function (OPRF) and an
   authenticated key exchange (AKE) protocol.  It can be seen as a
   "compiler" for transforming any suitable AKE protocol into a secure
   aPAKE protocol.  (See Section 8 for requirements of the OPRF and AKE
   protocols.)  This document specifies one OPAQUE instantiation based
   on 3DH [SIGNAL].  Other instantiations are possible, as discussed in
   Appendix B, but their details are out of scope for this document.  In
   general, the modularity of OPAQUE's design makes it easy to integrate
   with additional AKE protocols, e.g., TLS, and with future ones such
   as those based on post-quantum techniques.

   OPAQUE consists of two stages: registration and authenticated key
   exchange.  In the first stage, a client registers its password with
   the server and stores its encrypted credentials on the server.  In
   the second stage, a client obtains those credentials, recovers them
   using the client's password, and subsequently uses them as input to
   an AKE protocol.

   Currently, the most widely deployed PKI-free aPAKE is SRP [RFC2945],
   which is vulnerable to pre-computation attacks, lacks proof of
   security, and is less efficient relative to OPAQUE.  Moreover, SRP
   requires a ring as it mixes addition and multiplication operations,
   and thus does not work over plain elliptic curves.  OPAQUE is
   therefore a suitable replacement for applications that use SRP.

   This draft complies with the requirements for PAKE protocols set
   forth in [RFC8125].

1.1.  Requirements Notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

1.2.  Notation

   The following functions are used throughout this document:

   *  I2OSP and OS2IP: Convert a byte string to and from a non-negative
      integer as described in Section 4 of [RFC8017].  Note that these
      functions operate on byte strings in big-endian byte order.

   *  concat(x0, ..., xN): Concatenate byte strings.  For example,
      "concat(0x01, 0x0203, 0x040506) = 0x010203040506".

   *  random(n): Generate a cryptographically secure pseudorandom byte
      string of length "n" bytes.

   *  xor(a,b): Apply XOR to byte strings.  For example, "xor(0xF0F0,
      0x1234) = 0xE2C4".  It is an error to call this function with two
      arguments of unequal length.

   *  ct_equal(a, b): Return "true" if "a" is equal to "b", and false
      otherwise.  This function is constant-time in the length of "a"
      and "b", which are assumed to be of equal length, irrespective of
      the values "a" or "b".

   Except if said otherwise, random choices in this specification refer
   to drawing with uniform distribution from a given set (i.e., "random"
   is short for "uniformly random").  Random choices can be replaced
   with fresh outputs from a cryptographically strong pseudorandom
   generator, according to the requirements in [RFC4086], or
   pseudorandom function.  For convenience, we define "nil" as a lack of
   value.

   The name OPAQUE is a homonym of O-PAKE where O is for Oblivious.  The
   name OPAKE was taken.

2.  Cryptographic Dependencies

   OPAQUE relies on the following cryptographic protocols and
   primitives:

   *  Oblivious Pseudorandom Function (OPRF, [I-D.irtf-cfrg-voprf],
      version -06):

      -  Blind(x): Convert input "x" into an element of the OPRF group,
         randomize it by some scalar "r", producing "M", and output
         ("r", "M").

      -  Evaluate(k, M): Evaluate input element "M" using private key
         "k", yielding output element "Z".

      -  Finalize(x, r, Z): Finalize the OPRF evaluation using input
         "x", random scalar "r", and evaluation output "Z", yielding
         output "y".

      -  DeriveKeyPair(seed): Derive a private and public key pair
         deterministically from a seed.

      -  Noe: The size of a serialized OPRF group element.

      -  Nok: The size of an OPRF private key.

   Note that we only need the base mode variant (as opposed to the
   verifiable mode variant) of the OPRF described in
   [I-D.irtf-cfrg-voprf].

   *  Key Derivation Function (KDF):

      -  Extract(salt, ikm): Extract a pseudorandom key of fixed length
         "Nx" bytes from input keying material "ikm" and an optional
         byte string "salt".

      -  Expand(prk, info, L): Expand a pseudorandom key "prk" using
         optional string "info" into "L" bytes of output keying
         material.

      -  Nx: The output size of the "Extract()" function in bytes.

   *  Message Authentication Code (MAC):

      -  MAC(key, msg): Compute a message authentication code over input
         "msg" with key "key", producing a fixed-length output of "Nm"
         bytes.

      -  Nm: The output size of the "MAC()" function in bytes.

   *  Hash Function:

      -  Hash(msg): Apply a cryptographic hash function to input "msg",
         producing a fixed-length digest of size "Nh" bytes.

      -  Nh: The output size of the "Hash()" function in bytes.

   *  Memory Hard Function (MHF):

      -  Harden(msg, params): Repeatedly apply a memory-hard function
         with parameters "params" to strengthen the input "msg" against
         offline dictionary attacks.  This function also needs to
         satisfy collision resistance.

   OPAQUE additionally depends on an Authenticated Key Exchange (AKE)
   protocol.  This specification defines one particular AKE based on
   3DH; see Section 6.2.  We let "Npk" and "Nsk" denote the size of
   public and private keys, respectively, used in the AKE.  The AKE
   protocol must provide the following functions:

   *  RecoverPublicKey(private_key): Recover the public key related to
      the input "private_key".

   *  DeriveAuthKeyPair(seed): Derive a private and public
      authentication key pair deterministically from the input "seed".

   *  GenerateKeyPair(): Return a randomly generated private and public
      key pair.  This can be implemented by generating a random private
      key "sk", then computing "pk = RecoverPublicKey(sk)".

   Finally, all random nonces used in this protocol are of length "Nn" =
   32 bytes.

3.  Protocol Overview

   OPAQUE consists of two stages: registration and authenticated key
   exchange.  In the first stage, a client registers its password with
   the server and stores its encrypted credentials on the server.  The
   client inputs its credentials, which includes its password and user
   identifier, and the server inputs its parameters, which includes its
   private key and other information.  The client output of this stage
   is a single value "export_key" that the client may use for
   application-specific purposes, e.g., to encrypt additional
   information to the server.  The server output of this stage is a
   record corresponding to the client's registration that it stores in a
   credential file alongside other client registrations as needed.

   Registration is the only part in OPAQUE that requires an
   authenticated and confidential channel, either physical, out-of-band,
   PKI-based, etc.

   The registration flow is shown below:

       creds                                   parameters
         |                                         |
         v                                         v
       Client                                    Server
       ------------------------------------------------
                   registration request
                ------------------------->
                   registration response
                <-------------------------
                         record
                ------------------------->
      ------------------------------------------------
         |                                         |
         v                                         v
     export_key                                 record

   In the second stage, a client obtains credentials previously
   registered with the server, recovers private key material using the
   password, and subsequently uses them as input to an AKE protocol.  As
   in the registration phase, the client inputs its credentials,
   including its password and user identifier, and the server inputs its
   parameters and the credential file record corresponding to the
   client.  The client outputs two values, an "export_key" (matching
   that from registration) and a "session_key", the latter of which is
   the primary AKE output.  The server outputs a single value
   "session_key" that matches that of the client.  Upon completion,
   clients and servers can use these values as needed.

   The authenticated key exchange flow is shown below:

       creds                             (parameters, record)
         |                                         |
         v                                         v
       Client                                    Server
       ------------------------------------------------
                      AKE message 1
                ------------------------->
                      AKE message 2
                <-------------------------
                      AKE message 3
                ------------------------->
      ------------------------------------------------
         |                                         |
         v                                         v
   (export_key, session_key)                  session_key

   The rest of this document describes the details of these stages in
   detail.  Section 4 describes how client credential information is
   generated, encoded, encrypted, and stored on the server.  Section 5
   describes the first registration stage of the protocol, and Section 6
   describes the second authentication stage of the protocol.  Section 7
   describes how to instantiate OPAQUE using different cryptographic
   dependencies and parameters.

4.  Client Credential Storage

   OPAQUE makes use of a structure "Envelope" to manage client
   credentials.  This envelope holds information about its format and
   content for the client to obtain its authentication material.

   OPAQUE allows applications to either provide custom client private
   and public keys for authentication, or to generate them internally.
   Each public and private key value is encoded as a byte string,
   specific to the AKE protocol in which OPAQUE is instantiated.  These
   two options are defined as the "internal" and "external" modes,
   respectively.  See Section 4.3 for their specifications.

   Applications may pin key material to identities if desired.  If no
   identity is given for a party, its value MUST default to its public
   key.  The following types of application credential information are
   considered:

   *  client_private_key: The encoded client private key for the AKE
      protocol.

   *  client_public_key: The encoded client public key for the AKE
      protocol.

   *  server_public_key: The encoded server public key for the AKE
      protocol.

   *  client_identity: The client identity.  This is an application-
      specific value, e.g., an e-mail address or normal account name.
      If not specified, it defaults to the client's public key.

   *  server_identity: The server identity.  This is typically a domain
      name, e.g., example.com.  If not specified, it defaults to the
      server's public key.  See Section 8.2 for information about this
      identity.

   These credential values are used in the "CleartextCredentials"
   structure as follows:

   struct {
     uint8 server_public_key[Npk];
     uint8 server_identity<1..2^16-1>;
     uint8 client_identity<1..2^16-1>;
   } CleartextCredentials;

   The function CreateCleartextCredentials constructs a
   "CleartextCredentials" structure given application credential
   information.

CreateCleartextCredentials(server_public_key, client_public_key,
                           server_identity, client_identity)

Input:
- server_public_key, The encoded server public key for the AKE protocol.
- client_public_key, The encoded client public key for the AKE protocol.
- server_identity, The optional encoded server identity.
- client_identity, The optional encoded client identity.

Output:
- cleartext_credentials, a CleartextCredentials structure

Steps:
1. if server_identity == nil
2.    server_identity = server_public_key
3. if client_identity == nil
4.    client_identity = client_public_key
5. Create CleartextCredentials cleartext_credentials
   with (server_public_key, server_identity, client_identity)
6. Output cleartext_credentials

4.1.  Envelope Structure

   A client "Envelope" is constructed based on the "EnvelopeMode",
   consisting of an "InnerEnvelope" entry whose structure is determined
   by the mode.  Future modes MAY introduce alternate "InnerEnvelope"
   contents.  "Envelope" is defined as follows:

   struct {
     uint8 nonce[Nn];
     InnerEnvelope inner_env;
     uint8 auth_tag[Nm];
   } Envelope;

   nonce: A unique nonce of length "Nn" used to protect this Envelope.

   auth_tag: Authentication tag protecting the contents of the envelope,
   covering the envelope nonce, "InnerEnvelope", and
   "CleartextCredentials".

   inner_env: A mode dependent "InnerEnvelope" structure.  See
   Section 4.3 for its specifications.

   The size of the serialized envelope is denoted "Ne" and varies based
   on the mode.  The exact value for "Ne" is specified in Section 4.3.1
   and Section 4.3.2.

4.2.  Envelope Creation and Recovery

   Clients create an "Envelope" at registration with the function
   "CreateEnvelope" defined below.

   For the "internal" mode, implementations can choose to leave out the
   "client_private_key" parameter, as it is not used.  For the
   "external" mode, implementations are free to additionally provide
   "client_public_key" to this function.  With this, the public key does
   not need to be recovered by "BuildInnerEnvelope()" and that function
   should be adapted accordingly.

CreateEnvelope(randomized_pwd, server_public_key, client_private_key,
               server_identity, client_identity)

Parameter:
- mode, the EnvelopeMode mode

Input:
- randomized_pwd, randomized password.
- server_public_key, The encoded server public key for
  the AKE protocol.
- client_private_key, The encoded client private key for
  the AKE protocol. This is nil in the internal key mode.
- server_identity, The optional encoded server identity.
- client_identity, The optional encoded client identity.

Output:
- envelope, the client's `Envelope` structure.
- client_public_key, the client's AKE public key.
- masking_key, a key used by the server to encrypt the
  envelope during login.
- export_key, an additional client key.

Steps:
1. envelope_nonce = random(Nn)
2. auth_key = Expand(randomized_pwd, concat(envelope_nonce, "AuthKey"), Nh)
3. export_key = Expand(randomized_pwd, concat(envelope_nonce, "ExportKey"), Nh)
4. masking_key = Expand(randomized_pwd, "MaskingKey", Nh)
5. inner_env, client_public_key = BuildInnerEnvelope(randomized_pwd, envelope_nonce, client_private_key)
6. cleartext_creds = CreateCleartextCredentials(server_public_key, client_public_key, server_identity, client_identity)
7. auth_tag = MAC(auth_key, concat(envelope_nonce, inner_env, cleartext_creds))
8. Create Envelope envelope with (envelope_nonce, inner_env, auth_tag)
9. Output (envelope, client_public_key, masking_key, export_key)

   Clients recover their "Envelope" during authentication with the
   "RecoverEnvelope" function defined below.

RecoverEnvelope(randomized_pwd, server_public_key, envelope,
                server_identity, client_identity)

Input:
- randomized_pwd, randomized password.
- server_public_key, The encoded server public key for the AKE protocol.
- envelope, the client's `Envelope` structure.
- server_identity, The optional encoded server identity.
- client_identity, The optional encoded client identity.

Output:
- client_private_key, The encoded client private key for the AKE protocol
- export_key, an additional client key

Steps:
1. auth_key = Expand(randomized_pwd, concat(envelope.nonce, "AuthKey"), Nh)
2. export_key = Expand(randomized_pwd, concat(envelope.nonce, "ExportKey", Nh)
3. (client_private_key, client_public_key) =
    RecoverKeys(randomized_pwd, envelope.nonce, envelope.inner_env)
4. cleartext_creds = CreateCleartextCredentials(server_public_key,
                      client_public_key, server_identity, client_identity)
5. expected_tag = MAC(auth_key, concat(envelope.nonce, inner_env, cleartext_creds))
6. If !ct_equal(envelope.auth_tag, expected_tag),
     raise MacError
7. Output (client_private_key, export_key)

4.3.  Envelope Modes

   The "EnvelopeMode" specifies the structure and encoding of the
   corresponding "InnerEnvelope".  This document specifies the values of
   the two aforementioned modes:

   enum {
     internal(1),
     external(2),
     (255)
   } EnvelopeMode;

   Each "EnvelopeMode" defines its own "InnerEnvelope" structure and
   must implement the following interface:

   *  "inner_env, client_public_key = BuildInnerEnvelope(randomized_pwd,
      nonce, client_private_key)": Build and return the mode's
      "InnerEnvelope" structure and the client's public key.

   *  "client_private_key, client_public_key =
      RecoverKeys(randomized_pwd, nonce, inner_env)": Recover and return
      the client's private and public keys for the AKE protocol.

   The implementations of this interface for both "internal" and
   "external" modes are in Section 4.3.1 and Section 4.3.2,
   respectively.

   The size of the envelope may vary between modes.  If applications
   implement Section 8.8, they MUST use the same envelope mode
   throughout their lifecycle in order to avoid activity leaks due to
   mode switching.

4.3.1.  Internal mode

   In this mode, the client's private and public keys are
   deterministically derived from the OPRF output.

   With the internal key mode the "EnvelopeMode" value MUST be
   "internal" and the "InnerEnvelope" is empty, and the size "Ne" of the
   serialized "Envelope" is "Nn + Nm".

   To generate the private key OPAQUE-3DH implements
   "DeriveAuthKeyPair(seed)" as follows:

   DeriveAuthKeyPair(seed)

   Input:
   - seed, pseudo-random byte sequence used as a seed.

   Output:
   - private_key, a private key
   - public_key, the associated public key

   Steps:
   1. private_key = HashToScalar(seed, dst="OPAQUE-HashToScalar")
   2. public_key = private_key * G
   3. Output (private_key, public_key)

   HashToScalar(msg, dst) is as specified in [I-D.irtf-cfrg-voprf],
   except that the "dst" parameter is "OPAQUE-HashToScalar".

   BuildInnerEnvelope(randomized_pwd, nonce, client_private_key)

   Input:
   - randomized_pwd, randomized password.
   - nonce, a unique nonce of length `Nn`.
   - client_private_key, empty value. Not used in this function,
     it only serves to comply with the API.

   Output:
   - inner_env, nil value (serves to comply with the API).
   - client_public_key, the client's AKE public key.

   Steps:
   1. seed = Expand(randomized_pwd, concat(nonce, "PrivateKey"), Nsk)
   2. _, client_public_key = DeriveAuthKeyPair(seed)
   3. Output (nil, client_public_key)

   Note that implementations are free to leave out the
   "client_private_key" parameter, as it is not used.

RecoverKeys(randomized_pwd, nonce, inner_env)

Input:
- randomized_pwd, randomized password.
- nonce, a unique nonce of length `Nn`.
- inner_env, an InnerEnvelope structure. Not used in this
  function, it only serves to comply with the API.

Output:
- client_private_key, The encoded client private key for the AKE protocol
- client_public_key, The encoded client public key for the AKE protocol

Steps:
1. seed = Expand(randomized_pwd, concat(nonce, "PrivateKey"), Nsk)
2. client_private_key, client_public_key = DeriveAuthKeyPair(seed)
4. Output (client_private_key, client_public_key)

   Note that implementations are free to leave out the "inner_env"
   parameter, as it is not used.

4.3.2.  External mode

   This mode allows applications to import or generate keys for the
   client.  This specification only imports the client's private key and
   internally recovers the corresponding public key.  Implementations
   are free to import both, in which case the functions
   "FinalizeRequest()", "CreateEnvelope()", and "BuildInnerEnvelope()"
   must be adapted accordingly.

   With the external key mode the "EnvelopeMode" value MUST be
   "external", and the size "Ne" of the serialized "Envelope" is "Nn +
   Nm + Nsk".

   An encryption key is generated from the hardened OPRF output and used
   to encrypt the client's private key, which is then stored encrypted
   in the "InnerEnvelope".  On key recovery, the client's public key is
   recovered using the private key.

   struct {
     uint8 encrypted_creds[Nsk];
   } InnerEnvelope;

   encrypted_creds : Encrypted client_private_key.  Authentication of
   this field is ensured with the "auth_tag" field in the envelope that
   covers this "InnerEnvelope".

   If the implementation provides the "client_public_key", then
   "BuildInnerEnvelope()" can skip the "RecoverPublicKey()" call.

BuildInnerEnvelope(randomized_pwd, nonce, client_private_key)

Input:
- randomized_pwd, randomized password.
- nonce, a unique nonce of length `Nn`.
- client_private_key, the encoded client private key for the AKE protocol.

Output:
- inner_env, an InnerEnvelope structure.
- client_public_key, The encoded client public key for the AKE protocol.

Steps:
1. pseudorandom_pad = Expand(randomized_pwd, concat(nonce, "Pad"), len(client_private_key))
2. encrypted_creds = xor(client_private_key, pseudorandom_pad)
3. Create InnerEnvelope inner_env with encrypted_creds
4. client_public_key = RecoverPublicKey(client_private_key)
5. Output (inner_env, client_public_key)

RecoverKeys(randomized_pwd, nonce, inner_env)

Input:
- randomized_pwd, randomized password.
- nonce, a unique nonce of length `Nn`.
- inner_env, an InnerEnvelope structure.

Output:
- client_private_key, the encoded client private key for the AKE protocol.
- client_public_key, the client's AKE public key.

Steps:
1. encrypted_creds = inner_env.encrypted_creds
2. pseudorandom_pad = Expand(randomized_pwd, concat(nonce, "Pad"), len(encrypted_creds))
3. client_private_key = xor(encrypted_creds, pseudorandom_pad)
4. client_public_key = RecoverPublicKey(client_private_key)
5. Output (client_private_key, client_public_key)

5.  Offline Registration

   This section describes the registration flow, message encoding, and
   helper functions.  In a setup phase, the client chooses its password,
   and the server chooses its own pair of private-public AKE keys
   (server_private_key, server_public_key) for use with the AKE, along
   with a Nh-byte oprf_seed.  The server can use the same pair of keys
   with multiple clients and can opt to use multiple seeds (so long as
   they are kept consistent for each client).  These steps can happen
   offline, i.e., before the registration phase.

   If using "external" mode, the client provides a key pair
   (client_private_key, client_public_key) for an AKE protocol which is
   suitable for use with OPAQUE; See Section 6.  The private-public keys
   (client_private_key, client_public_key) may be randomly generated
   (using a cryptographically secure pseudorandom number generator) for
   the account or provided by the calling client.  Clients MUST NOT use
   the same key pair (client_private_key, client_public_key) for two
   different accounts.

   Once complete, the registration process proceeds as follows.  The
   client inputs the following values:

   *  password: client password.

   *  creds: client credentials, as described in Section 4.

   The server inputs the following values:

   *  server_private_key: server private key for the AKE protocol.

   *  server_public_key: server public key for the AKE protocol.

   *  credential_identifier: client credential identifier.

   *  oprf_seed: seed used to derive per-client OPRF keys.

   The registration protocol then runs as shown below:

     Client                                         Server
    ------------------------------------------------------
    (request, blind) = CreateRegistrationRequest(password)

                           request
                 ------------------------->

   (response, oprf_key) = CreateRegistrationResponse(request,
                             server_public_key,
                             credential_identifier,
                             oprf_seed)

                           response
                 <-------------------------

    (record, export_key) = FinalizeRequest(client_private_key,
                                           password,
                                           blind,
                                           response,
                                           server_identity,
                                           client_identity)

                           record
                 ------------------------->

   Section 5.1.1 describes details of the functions and the
   corresponding parameters referenced above.

   Both client and server MUST validate the other party's public key
   before use.  See Section 8.6 for more details.  Upon completion, the
   server stores the client's credentials for later use.  Moreover, the
   client MAY use the output "export_key" for further application-
   specific purposes; see Section 8.4.

5.1.  Registration Messages

   struct {
     uint8 data[Noe];
   } RegistrationRequest;

   data  A serialized OPRF group element.

   struct {
     uint8 data[Noe];
     uint8 server_public_key[Npk];
   } RegistrationResponse;

   data  A serialized OPRF group element.

   server_public_key  The server's encoded public key that will be used
      for the online authenticated key exchange stage.

   struct {
     uint8 client_public_key[Npk];
     uint8 masking_key[Nh];
     Envelope envelope;
   } RegistrationUpload;

   client_public_key  The client's encoded public key, corresponding to
      the private key "client_private_key".

   masking_key  A key used by the server to preserve confidentiality of
      the envelope during login.

   envelope  The client's "Envelope" structure.

5.1.1.  Registration Functions

5.1.1.1.  CreateRegistrationRequest

   CreateRegistrationRequest(password)

   Input:
   - password, an opaque byte string containing the client's password.

   Output:
   - request, a RegistrationRequest structure.
   - blind, an OPRF scalar value.

   Steps:
   1. (blind, M) = Blind(password)
   2. Create RegistrationRequest request with M
   3. Output (request, blind)

5.1.1.2.  CreateRegistrationResponse

CreateRegistrationResponse(request, server_public_key, credential_identifier, oprf_seed)

Input:
- request, a RegistrationRequest structure.
- server_public_key, the server's public key.
- credential_identifier, an identifier that uniquely represents the credential being
  registered.
- oprf_seed, the server-side seed of Nh bytes used to generate an oprf_key.

Output:
- response, a RegistrationResponse structure.
- oprf_key, the per-client OPRF key known only to the server.

Steps:
1. ikm = Expand(oprf_seed, concat(credential_identifier, "OprfKey"), Nok)
2. (oprf_key, _) = DeriveKeyPair(ikm)
3. Z = Evaluate(oprf_key, request.data)
4. Create RegistrationResponse response with (Z, server_public_key)
5. Output (response, oprf_key)

5.1.1.3.  FinalizeRequest

   To create the user record used for further authentication, the client
   executes the following function.  In the internal key mode, the
   "client_private_key" is nil.

   Depending on the mode, implementations are free to leave out the
   "client_private_key" parameter ("internal" mode), or to additionally
   include "client_public_key" ("external" mode).  See Section 4.2 for
   more details.

FinalizeRequest(client_private_key, password, blind, response,
                server_identity, client_identity)

Input:
- client_private_key, the client's private key. In internal mode, this is nil.
- password, an opaque byte string containing the client's password.
- blind, the OPRF scalar value used for blinding.
- response, a RegistrationResponse structure.
- server_identity, the optional encoded server identity.
- client_identity, the optional encoded client identity.

Output:
- record, a RegistrationUpload structure.
- export_key, an additional client key.

Steps:
1. y = Finalize(password, blind, response.data)
2. randomized_pwd = Extract("", Harden(y, params))
3. (envelope, client_public_key, masking_key, export_key) =
    CreateEnvelope(randomized_pwd, response.server_public_key, client_private_key,
                   server_identity, client_identity)
4. Create RegistrationUpload record with (client_public_key, masking_key, envelope)
5. Output (record, export_key)

   See Section 6 for details about the output export_key usage.

   Upon completion of this function, the client MUST send "record" to
   the server.

5.1.1.4.  Finalize Registration

   The server stores the "record" object as the credential file for each
   client along with the associated "credential_identifier" and
   "client_identity" (if different).  Note that the values "oprf_seed"
   and "server_private_key" from the server's setup phase must also be
   persisted.

6.  Online Authenticated Key Exchange

   The generic outline of OPAQUE with a 3-message AKE protocol includes
   three messages ke1, ke2, and ke3, where ke1 and ke2 include key
   exchange shares, e.g., DH values, sent by the client and server,
   respectively, and ke3 provides explicit client authentication and
   full forward security (without it, forward secrecy is only achieved
   against eavesdroppers, which is insufficient for OPAQUE security).

   This section describes the online authenticated key exchange protocol
   flow, message encoding, and helper functions.  This stage is composed
   of a concurrent OPRF and key exchange flow.  The key exchange
   protocol is authenticated using the client and server credentials
   established during registration; see Section 5.  In the end, the
   client proves its knowledge of the password, and both client and
   server agree on a mutually authenticated shared secret key.

   In this stage, the client inputs the following values:

   *  password: client password.

   *  client_identity: client identity, as described in Section 4.

   The server inputs the following values:

   *  server_private_key: server private for the AKE protocol.

   *  server_public_key: server public for the AKE protocol.

   *  server_identity: server identity, as described in Section 4.

   *  record: RegistrationUpload corresponding to the client's
      registration.

   *  credential_identifier: client credential identifier.

   *  oprf_seed: seed used to derive per-client OPRF keys.

   The client receives two outputs: a session secret and an export key.
   The export key is only available to the client, and may be used for
   additional application-specific purposes, as outlined in Section 8.4.
   The output "export_key" MUST NOT be used in any way before the
   protocol completes successfully.  See Section 8.3 for more details
   about this requirement.  The server receives a single output: a
   session secret matching that of the client's.

   The protocol runs as shown below:

     Client                                         Server
    ------------------------------------------------------
     ke1 = ClientInit(client_identity, password)

                            ke1
                 ------------------------->

     ke2 = ServerInit(server_identity, server_private_key,
                       server_public_key, record,
                       credential_identifier, oprf_seed, ke1)

                            ke2
                 <-------------------------

       (ke3,
       session_key,
       export_key) = ClientFinish(password, client_identity,
                                 server_identity, ke2)

                            ke3
                 ------------------------->

                          session_key = ServerFinish(ke3)

   The rest of this section describes these authenticated key exchange
   messages and their parameters in more detail.  Section 6.1 discusses
   internal functions used for retrieving client credentials, and
   Section 6.2 discusses how these functions are used to execute the
   authenticated key exchange protocol.

6.1.  Credential Retrieval

6.1.1.  Credential Retrieval Messages

   struct {
     uint8 data[Noe];
   } CredentialRequest;

   data  A serialized OPRF group element.

   struct {
     uint8 data[Noe];
     uint8 masking_nonce[Nn];
     uint8 masked_response[Npk + Ne];
   } CredentialResponse;

   data  A serialized OPRF group element.

   masking_nonce  A nonce used for the confidentiality of the
      masked_response field

   masked_response  An encrypted form of the server's public key and the
      client's "Envelope" structure

6.1.2.  Credential Retrieval Functions

6.1.2.1.  CreateCredentialRequest

   CreateCredentialRequest(password)

   Input:
   - password, an opaque byte string containing the client's password.

   Output:
   - request, a CredentialRequest structure.
   - blind, an OPRF scalar value.

   Steps:
   1. (blind, M) = Blind(password)
   2. Create CredentialRequest request with M
   3. Output (request, blind)

6.1.2.2.  CreateCredentialResponse

   There are two scenarios to handle for the construction of a
   CredentialResponse object: either the record for the client exists
   (corresponding to a properly registered client), or it was never
   created (corresponding to a client that has yet to register).

   In the case of an existing record with the corresponding identifier
   "credential_identifier", the server invokes the following function to
   produce a CredentialResponse:

CreateCredentialResponse(request, server_public_key, record,
                         credential_identifier, oprf_seed)

Input:
- request, a CredentialRequest structure.
- server_public_key, the public key of the server.
- record, an instance of RegistrationUpload which is the server's
  output from registration.
- credential_identifier, an identifier that uniquely represents the credential
  being registered.
- oprf_seed, the server-side seed of Nh bytes used to generate an oprf_key.

Output:
- response, a CredentialResponse structure.

Steps:
1. ikm = Expand(oprf_seed, concat(credential_identifier, "OprfKey"), Nok)
2. (oprf_key, _) = DeriveKeyPair(ikm)
3. Z = Evaluate(oprf_key, request.data)
4. masking_nonce = random(32)
5. credential_response_pad = Expand(record.masking_key,
     concat(masking_nonce, "CredentialResponsePad"), Npk + Ne)
6. masked_response = xor(credential_response_pad,
                         concat(server_public_key, record.envelope))
7. Create CredentialResponse response with (Z, masking_nonce, masked_response)
8. Output response

   In the case of a record that does not exist, the server invokes the
   CreateCredentialResponse function where the record argument is
   configured so that:

   *  record.masking_key is set to a random byte string of length Nh,
      and

   *  record.envelope is set to the byte string consisting only of
      zeros, of length Ne

   Note that the responses output by either scenario are
   indistinguishable to an adversary that is unable to guess the
   registered password for the client corresponding to
   credential_identifier.

6.1.2.3.  RecoverCredentials

 RecoverCredentials(password, blind, response,
                    server_identity, client_identity)

 Input:
 - password, an opaque byte string containing the client's password.
 - blind, an OPRF scalar value.
 - response, a CredentialResponse structure.
 - server_identity, The optional encoded server identity.
 - client_identity, The optional encoded client identity.

 Output:
 - client_private_key, the client's private key for the AKE protocol.
 - server_public_key, the public key of the server.
 - export_key, an additional client key.

 Steps:
 1. y = Finalize(password, blind, response.data)
 2. randomized_pwd = Extract("", Harden(y, params))
 3. masking_key = Expand(randomized_pwd, "MaskingKey", Nh)
 4. credential_response_pad = Expand(masking_key,
      concat(response.masking_nonce, "CredentialResponsePad"), Npk + Ne)
 5. concat(server_public_key, envelope) = xor(credential_response_pad,
                                               response.masked_response)
 6. (client_private_key, export_key) =
     RecoverEnvelope(randomized_pwd, server_public_key, envelope,
                     server_identity, client_identity)
 7. Output (client_private_key, response.server_public_key, export_key)

6.2.  AKE Protocol

   This section describes the authenticated key exchange protocol for
   OPAQUE using 3DH, a 3-message AKE which satisfies the forward secrecy
   and KCI properties discussed in Section 8.  The protocol consists of
   three messages sent between client and server, each computed using
   the following application APIs:

   *  ke1 = ClientInit(client_identity, password)

   *  ke2 = ServerInit(server_identity, server_private_key,
      server_public_key, record, credential_identifier, oprf_seed, ke1)

   *  ke3, session_key, export_key = ClientFinish(password,
      client_identity, server_identity, ke2)

   *  session_key = ServerFinish(ke3)

   Outputs "ke1", "ke2", and "ke3" are the three protocol messages sent
   between client and server. "session_key" and "export_key" are outputs
   to be consumed by applications.  Applications can use "session_key"
   to derive additional keying material as needed.

   Both ClientFinish and ServerFinish return an error if authentication
   failed.  In this case, clients and servers MUST NOT use any outputs
   from the protocol, such as "session_key" or "export_key".  ClientInit
   and ServerInit both implicitly return internal state objects
   "client_state" and "server_state", respectively, with the following
   named fields:

   struct {
     uint8 blind[Nok];
     uint8 client_secret[Nsk];
     KE1 ke1;
   } ClientState;

   struct {
     uint8 expected_client_mac[Nm];
     uint8 session_key[Nx];
   } ServerState;

   Section 6.2.3 and Section 6.2.4 specify the inner working of these
   functions and their parameters for clients and servers, respectively.

   Prior to the execution of these functions, both the client and the
   server MUST agree on a configuration; see Section 7 for details.

6.2.1.  Protocol Messages

   struct {
     CredentialRequest request;
     uint8 client_nonce[Nn];
     uint8 client_keyshare[Npk];
   } KE1;

   request  A "CredentialRequest" generated according to
      Section 6.1.2.1.

   client_nonce  A fresh randomly generated nonce of length "Nn".

   client_keyshare  Client ephemeral key share of fixed size Npk, where
      Npk depends on the corresponding prime order group.

   struct {
     struct {
       CredentialResponse response;
       uint8 server_nonce[Nn];
       uint8 server_keyshare[Npk];
     } inner_ke2;
     uint8 server_mac[Nm];
   } KE2;

   response  A "CredentialResponse" generated according to
      Section 6.1.2.2.

   server_nonce  A fresh randomly generated nonce of length "Nn".

   server_keyshare  Server ephemeral key share of fixed size Npk, where
      Npk depends on the corresponding prime order group.

   server_mac  An authentication tag computed over the handshake
      transcript computed using Km2, defined below.

   struct {
     uint8 client_mac[Nm];
   } KE3;

   client_mac  An authentication tag computed over the handshake
      transcript computed using Km2, defined below.

6.2.2.  Key Schedule Functions

6.2.2.1.  Transcript Functions

   The OPAQUE-3DH key derivation procedures make use of the functions
   below, re-purposed from TLS 1.3 [RFC8446].

   Expand-Label(Secret, Label, Context, Length) =
       Expand(Secret, CustomLabel, Length)

   Where CustomLabel is specified as:

   struct {
     uint16 length = Length;
     opaque label<8..255> = "OPAQUE-" + Label;
     uint8 context<0..255> = Context;
   } CustomLabel;

   Derive-Secret(Secret, Label, Transcript-Hash) =
       Expand-Label(Secret, Label, Transcript-Hash, Nx)

   Note that the Label parameter is not a NULL-terminated string.

   OPAQUE-3DH can optionally include shared "context" information in the
   transcript, such as configuration parameters or application-specific
   info, e.g. "appXYZ-v1.2.3".

   The OPAQUE-3DH key schedule requires a preamble, which is computed as
   follows.

   Preamble(client_identity, ke1, server_identity, inner_ke2)

   Parameters:
   - context, optional shared context information.

   Input:
   - client_identity, the optional encoded client identity, which is set
     to client_public_key if not specified.
   - ke1, a KE1 message structure.
   - server_identity, the optional encoded server identity, which is set
     to server_public_key if not specified.
   - inner_ke2, an inner_ke2 structure as defined in KE2.

   Output:
   - preamble, the protocol transcript with identities and messages.

   Steps:
   1. preamble = concat("RFCXXXX",
                        I2OSP(len(context), 2), context,
                        I2OSP(len(client_identity), 2), client_identity,
                        ke1,
                        I2OSP(len(server_identity), 2), server_identity,
                        inner_ke2)
   2. Output preamble

6.2.2.2.  Shared Secret Derivation

   The OPAQUE-3DH shared secret derived during the key exchange protocol
   is computed using the following function.

   TripleDHIKM(sk1, pk1, sk2, pk2, sk3, pk3)

   Input:
   - skx, scalar to be multiplied with their corresponding pkx.
   - pkx, element to be multiplied with their corresponding skx.

   Output:
   - ikm, input key material.

   Steps:
   1. dh1 = sk1 * pk1
   2. dh2 = sk2 * pk2
   3. dh3 = sk3 * pk3
   4. Output concat(dh1, dh2, dh3)

   Using this shared secret, further keys used for encryption and
   authentication are computed using the following function.

DeriveKeys(ikm, preamble)

Input:
- ikm, input key material.
- preamble, the transcript as defined by Preamble().

Output:
- Km2, a MAC authentication key.
- Km3, a MAC authentication key.
- session_key, the shared session secret.

Steps:
1. prk = Extract("", ikm)
2. handshake_secret = Derive-Secret(prk, "HandshakeSecret", Hash(preamble))
3. session_key = Derive-Secret(prk, "SessionKey", Hash(preamble))
4. Km2 = Derive-Secret(handshake_secret, "ServerMAC", "")
5. Km3 = Derive-Secret(handshake_secret, "ClientMAC", "")
6. Output (Km2, Km3, session_key)

6.2.3.  External Client API

ClientInit(client_identity, password)

State:
- state, a ClientState structure.

Input:
- client_identity, the optional encoded client identity, which is nil
  if not specified.
- password, an opaque byte string containing the client's password.

Output:
- ke1, a KE1 message structure.
- blind, the OPRF blinding scalar.
- client_secret, the client's Diffie-Hellman secret share for the session.

Steps:
1. request, blind = CreateCredentialRequest(password)
2. state.blind = blind
3. ke1 = Start(request)
4. Output ke1

ClientFinish(password, client_identity, server_identity, ke1, ke2)

State:
- state, a ClientState structure

Input:
- password, an opaque byte string containing the client's password.
- client_identity, the optional encoded client identity, which is set
  to client_public_key if not specified.
- server_identity, the optional encoded server identity, which is set
  to server_public_key if not specified.
- ke1, a KE1 message structure.
- ke2, a KE2 message structure.

Output:
- ke3, a KE3 message structure.
- session_key, the session's shared secret.

Steps:
1. (client_private_key, server_public_key, export_key) =
    RecoverCredentials(password, state.blind, ke2.CredentialResponse,
                       server_identity, client_identity)
2. (ke3, session_key) =
    ClientFinalize(client_identity, client_private_key, server_identity,
                    server_public_key, ke1, ke2)
3. Output (ke3, session_key)

6.2.3.1.  Internal Client Functions

Start(credential_request)

Parameters:
- Nn, the nonce length.

State:
- state, a ClientState structure.

Input:
- credential_request, a CredentialRequest structure.

Output:
- ke1, a KE1 structure.

Steps:
1. client_nonce = random(Nn)
2. client_secret, client_keyshare = GenerateKeyPair()
3. Create KE1 ke1 with (credential_request, client_nonce, client_keyshare)
4. state.client_secret = client_secret
5. Output (ke1, client_secret)

ClientFinalize(client_identity, client_private_key, server_identity,
               server_public_key, ke1, ke2)

State:
- state, a ClientState structure.

Input:
- client_identity, the optional encoded client identity, which is
  set to client_public_key if not specified.
- client_private_key, the client's private key.
- server_identity, the optional encoded server identity, which is
  set to server_public_key if not specified.
- server_public_key, the server's public key.
- ke2, a KE2 message structure.

Output:
- ke3, a KE3 structure.
- session_key, the shared session secret.

Steps:
1. ikm = TripleDHIKM(state.client_secret, ke2.server_keyshare,
    state.client_secret, server_public_key, client_private_key, ke2.server_keyshare)
2. preamble = Preamble(client_identity, state.ke1, server_identity, ke2.inner_ke2)
3. Km2, Km3, session_key = DeriveKeys(ikm, preamble)
4. expected_server_mac = MAC(Km2, Hash(preamble))
5. If !ct_equal(ke2.server_mac, expected_server_mac),
     raise MacError
6. client_mac = MAC(Km3, Hash(concat(preamble, expected_server_mac))
7. Create KE3 ke3 with client_mac
8. Output (ke3, session_key)

6.2.4.  External Server API

ServerInit(server_identity, server_private_key, server_public_key,
           record, credential_identifier, oprf_seed, ke1)

Input:
- server_identity, the optional encoded server identity, which is set to
  server_public_key if nil.
- server_private_key, the server's private key.
- server_public_key, the server's public key.
- record, the client's RegistrationUpload structure.
- credential_identifier, an identifier that uniquely represents the credential
  being registered.
- oprf_seed, the server-side seed of Nh bytes used to generate an oprf_key.
- ke1, a KE1 message structure.

Output:
- ke2, a KE2 structure.

Steps:
1. response = CreateCredentialResponse(ke1.request, server_public_key, record,
    credential_identifier, oprf_seed)
2. ke2 = Response(server_identity, server_private_key,
    client_identity, record.client_public_key, ke1, response)
3. Output ke2

ServerFinish(ke3)

State:
- state, a ServerState structure.

Input:
- ke3, a KE3 structure.

Output:
- session_key, the shared session secret if, and only if, KE3 is valid, nil otherwise.

Steps:
1. if ct_equal(ke3.client_mac, state.expected_client_mac):
2.    Output state.session_key
3. Output nil

6.2.4.1.  Internal Server Functions

Response(server_identity, server_private_key, client_identity,
         client_public_key, ke1, credential_response)

Parameters:
- Nn, the nonce length.

State:
- state, a ServerState structure.

Input:
- server_identity, the optional encoded server identity, which is set to
  server_public_key if not specified.
- server_private_key, the server's private key.
- client_identity, the optional encoded client identity, which is set to
  client_public_key if not specified.
- client_public_key, the client's public key.
- ke1, a KE1 message structure.
- credential_response, a CredentialResponse structure.

Output:
- ke2, A KE2 structure.

Steps:
1. server_nonce = random(Nn)
2. server_secret, server_keyshare = GenerateKeyPair()
3. Create inner_ke2 ike2 with (credential_response, server_nonce, server_keyshare)
4. preamble = Preamble(client_identity, ke1, server_identity, ike2)
5. ikm = TripleDHIKM(server_secret, ke1.client_keyshare, server_private_key, ke1.client_keyshare, server_secret, client_public_key)
6. Km2, Km3, session_key = DeriveKeys(ikm, preamble)
7. server_mac = MAC(Km2, Hash(preamble))
8. expected_client_mac = MAC(Km3, Hash(concat(preamble, server_mac))
9. Populate state with ServerState(expected_client_mac, session_key)
10. Create KE2 ke2 with (ike2, server_mac)
11. Output ke2

7.  Configurations

   An OPAQUE-3DH configuration is a tuple (OPRF, KDF, MAC, Hash, MHF,
   EnvelopeMode, Group, Context) such that the following conditions are
   met:

   *  The OPRF protocol uses the "base mode" variant of
      [I-D.irtf-cfrg-voprf] and implements the interface in Section 2.
      Examples include OPRF(ristretto255, SHA-512) and OPRF(P-256, SHA-
      256).

   *  The KDF, MAC, and Hash functions implement the interfaces in
      Section 2.  Examples include HKDF [RFC5869] for the KDF, HMAC
      [RFC2104] for the MAC, and SHA-256 and SHA-512 for the Hash
      functions.  If an extensible output function such as SHAKE128
      [FIPS202] is used then the output length "Nh" MUST be chosen to
      align with the target security level of the OPAQUE configuration.
      For example, if the target security parameter for the
      configuration is 128-bits, then "Nh" SHOULD be at least 32 bytes.

   *  The MHF has fixed parameters, chosen by the application, and
      implements the interface in Section 2.  Examples include Argon2
      [I-D.irtf-cfrg-argon2], scrypt [RFC7914], and PBKDF2 [RFC2898]
      with fixed parameter choices.

   *  EnvelopeMode value is as defined in Section 4, and is one of
      "internal" or "external".

   *  The Group mode identifies the group used in the OPAQUE-3DH AKE.
      This SHOULD match that of the OPRF.  For example, if the OPRF is
      OPRF(ristretto255, SHA-512), then Group SHOULD be ristretto255.

   Context is the shared parameter used to construct the preamble in
   Section 6.2.2.1.  This parameter SHOULD include any application-
   specific configuration information or parameters that are needed to
   prevent cross-protocol or downgrade attacks.

   Absent an application-specific profile, the following configurations
   are RECOMMENDED:

   *  OPRF(ristretto255, SHA-512), HKDF-SHA-512, HMAC-SHA-512, SHA-512,
      Scrypt(32768,8,1), internal, ristretto255

   *  OPRF(P-256, SHA-256), HKDF-SHA-256, HMAC-SHA-256, SHA-256,
      Scrypt(32768,8,1), internal, P-256

   Future configurations may specify different combinations of dependent
   algorithms, with the following considerations:

   1.  The size of AKE public and private keys -- "Npk" and "Nsk",
       respectively -- must adhere to the output length limitations of
       the KDF Expand function.  If HKDF is used, this means Npk, Nsk <=
       255 * Nx, where Nx is the output size of the underlying hash
       function.  See [RFC5869] for details.

   2.  The output size of the Hash function SHOULD be long enough to
       produce a key for MAC of suitable length.  For example, if MAC is
       HMAC-SHA256, then "Nh" could be the 32 bytes.

8.  Security Considerations

   OPAQUE is defined and proven as the composition of two
   functionalities: an OPRF and an AKE protocol.  It can be seen as a
   "compiler" for transforming any AKE protocol (with KCI security and
   forward secrecy - see below) into a secure aPAKE protocol.  In
   OPAQUE, the client stores a secret private key at the server during
   password registration and retrieves this key each time it needs to
   authenticate to the server.  The OPRF security properties ensure that
   only the correct password can unlock the private key while at the
   same time avoiding potential offline guessing attacks.  This general
   composability property provides great flexibility and enables a
   variety of OPAQUE instantiations, from optimized performance to
   integration with TLS.  The latter aspect is of prime importance as
   the use of OPAQUE with TLS constitutes a major security improvement
   relative to the standard password-over-TLS practice.  At the same
   time, the combination with TLS builds OPAQUE as a fully functional
   secure communications protocol and can help provide privacy to
   account information sent by the client to the server prior to
   authentication.

   The KCI property required from AKE protocols for use with OPAQUE
   states that knowledge of a party's private key does not allow an
   attacker to impersonate others to that party.  This is an important
   security property achieved by most public-key based AKE protocols,
   including protocols that use signatures or public key encryption for
   authentication.  It is also a property of many implicitly
   authenticated protocols, e.g., HMQV, but not all of them.  We also
   note that key exchange protocols based on shared keys do not satisfy
   the KCI requirement, hence they are not considered in the OPAQUE
   setting.  We note that KCI is needed to ensure a crucial property of
   OPAQUE: even upon compromise of the server, the attacker cannot
   impersonate the client to the server without first running an
   exhaustive dictionary attack.  Another essential requirement from AKE
   protocols for use in OPAQUE is to provide forward secrecy (against
   active attackers).

8.1.  Related Analysis

   Jarecki et al.  [OPAQUE] proved the security of OPAQUE in a strong
   aPAKE model that ensures security against pre-computation attacks and
   is formulated in the Universal Composability (UC) framework
   [Canetti01] under the random oracle model.  This assumes security of
   the OPRF function and the underlying key exchange protocol.  In turn,
   the security of the OPRF protocol from [I-D.irtf-cfrg-voprf] is
   proven in the random oracle model under the One-More Diffie-Hellman
   assumption [JKKX16].

   Very few aPAKE protocols have been proven formally, and those proven
   were analyzed in a weak security model that allows for pre-
   computation attacks (e.g., [GMR06]).  This is not just a formal
   issue: these protocols are actually vulnerable to such attacks.  This
   includes protocols that have recent analyses in the UC model such as
   AuCPace [AuCPace] and SPAKE2+ [SPAKE2plus].  We note that as shown in
   [OPAQUE], these protocols, and any aPAKE in the model from [GMR06],
   can be converted into an aPAKE secure against pre-computation attacks
   at the expense of an additional OPRF execution.

   OPAQUE's design builds on a line of work initiated in the seminal
   paper of Ford and Kaliski [FK00] and is based on the HPAKE protocol
   of Xavier Boyen [Boyen09] and the (1,1)-PPSS protocol from Jarecki et
   al.  [JKKX16].  None of these papers considered security against pre-
   computation attacks or presented a proof of aPAKE security (not even
   in a weak model).

8.2.  Identities

   AKE protocols generate keys that need to be uniquely and verifiably
   bound to a pair of identities.  In the case of OPAQUE, those
   identities correspond to client_identity and server_identity.  Thus,
   it is essential for the parties to agree on such identities,
   including an agreed bit representation of these identities as needed.

   Applications may have different policies about how and when
   identities are determined.  A natural approach is to tie
   client_identity to the identity the server uses to fetch envelope
   (hence determined during password registration) and to tie
   server_identity to the server identity used by the client to initiate
   an offline password registration or online authenticated key exchange
   session. server_identity and client_identity can also be part of the
   envelope or be tied to the parties' public keys.  In principle,
   identities may change across different sessions as long as there is a
   policy that can establish if the identity is acceptable or not to the
   peer.  However, we note that the public keys of both the server and
   the client must always be those defined at the time of password
   registration.

   The client identity (client_identity) and server identity
   (server_identity) are optional parameters that are left to the
   application to designate as monikers for the client and server.  If
   the application layer does not supply values for these parameters,
   then they will be omitted from the creation of the envelope during
   the registration stage.  Furthermore, they will be substituted with
   client_identity = client_public_key and server_identity =
   server_public_key during the authenticated key exchange stage.

   The advantage to supplying a custom client_identity and
   server_identity (instead of simply relying on a fallback to
   client_public_key and server_public_key) is that the client can then
   ensure that any mappings between client_identity and
   client_public_key (and server_identity and server_public_key) are
   protected by the authentication from the envelope.  Then, the client
   can verify that the client_identity and server_identity contained in
   its envelope match the client_identity and server_identity supplied
   by the server.

   However, if this extra layer of verification is unnecessary for the
   application, then simply leaving client_identity and server_identity
   unspecified (and using client_public_key and server_public_key
   instead) is acceptable.

8.3.  Envelope Encryption

   The analysis of OPAQUE from [OPAQUE] requires the authenticated
   encryption scheme used to produce the envelope in the external mode
   to have a special property called random key-robustness (or key-
   committing).  This specification enforces this property by utilizing
   encrypt-then-MAC in the construction of the envelope.  There is no
   option to use another authenticated encryption scheme with this
   specification.  (Deviating from the key-robustness requirement may
   open the protocol to attacks, e.g., [LGR20].)  We remark that
   export_key for authentication or encryption requires no special
   properties from the authentication or encryption schemes as long as
   export_key is used only after the envelope is validated, i.e., after
   the MAC in RecoverCredentials passes verification.

8.4.  Export Key Usage

   The export key can be used (separately from the OPAQUE protocol) to
   provide confidentiality and integrity to other data which only the
   client should be able to process.  For instance, if the server is
   expected to maintain any client-side secrets which require a password
   to access, then this export key can be used to encrypt these secrets
   so that they remain hidden from the server.

8.5.  Static Diffie-Hellman Oracles

   While one can expect the practical security of the OPRF function
   (namely, the hardness of computing the function without knowing the
   key) to be in the order of computing discrete logarithms or solving
   Diffie-Hellman, Brown and Gallant [BG04] and Cheon [Cheon06] show an
   attack that slightly improves on generic attacks.  For typical
   curves, the attack requires an infeasible number of calls to the OPRF
   or results in insignificant security loss; see [I-D.irtf-cfrg-voprf]
   for more information.  For OPAQUE, these attacks are particularly
   impractical as they translate into an infeasible number of failed
   authentication attempts directed at individual users.

8.6.  Input Validation

   Both client and server MUST validate the other party's public key(s)
   used for the execution of OPAQUE.  This includes the keys shared
   during the offline registration phase, as well as any keys shared
   during the online key agreement phase.  The validation procedure
   varies depending on the type of key.  For example, for OPAQUE
   instantiations using 3DH with P-256, P-384, or P-521 as the
   underlying group, validation is as specified in Section 5.6.2.3.4 of
   [keyagreement].  This includes checking that the coordinates are in
   the correct range, that the point is on the curve, and that the point
   is not the point at infinity.  Additionally, validation MUST ensure
   the Diffie-Hellman shared secret is not the point at infinity.

8.7.  OPRF Hardening

   Hardening the output of the OPRF greatly increases the cost of an
   offline attack upon the compromise of the credential file at the
   server.  Applications SHOULD select parameters that balance cost and
   complexity.

8.8.  Preventing Client Enumeration

   Client enumeration refers to attacks where the attacker tries to
   learn extra information about the behavior of clients that have
   registered with the server.  There are two types of attacks we
   consider: 1) An attacker tries to learn whether a given client
   identity is registered with a server, and 2) An attacker tries to
   learn whether a given client identity has recently completed
   registration, or has re-registered (e.g. after a password change).

   Preventing the first type of attack requires the server to act with
   unregistered client identities in a way that is indistinguishable
   from its behavior with existing registered clients.  This is achieved
   in Section 6.1.2.2 for an unregistered client by simulating a
   CredentialResponse for unregistered clients through the sampling of a
   random masking_key value and relying on the semantic security
   provided by the XOR-based pad over the envelope.

   Implementations must employ care to avoid side-channel leakage (e.g.,
   timing attacks) from helping differentiate these operations from a
   regular server response.

   Preventing the second type of attack requires the server to supply a
   credential_identifier value for a given client identity, consistently
   between the Section 5.1.1.2 and Section 6.1.2.2 steps.  Note that
   credential_identifier can be set to client_identity, for simplicity.

   In the event of a server compromise that results in a re-registration
   of credentials for all compromised clients, the oprf_seed value must
   be resampled, resulting in a change in the oprf_key value for each
   client.  Although this change can be detected by an adversary, it is
   only leaked upon password rotation after the exposure of the
   credential files.

   Applications must use the same envelope mode when using this
   prevention throughout their lifecycle.  The envelope size varies from
   one to another, and a switch in envelope mode could then be detected.

   Finally, note that server implementations may choose to forego the
   construction of a simulated credential response message for an
   unregistered client if these client enumeration attacks can be
   mitigated through other application-specific means.

8.9.  Password Salt and Storage Implications

   In OPAQUE, the OPRF key acts as the secret salt value that ensures
   the infeasibility of pre-computation attacks.  No extra salt value is
   needed.  Also, clients never disclose their passwords to the server,
   even during registration.  Note that a corrupted server can run an
   exhaustive offline dictionary attack to validate guesses for the
   client's password; this is inevitable in any aPAKE protocol.  (OPAQUE
   enables defense against such offline dictionary attacks by
   distributing the server so that an offline attack is only possible if
   all - or a minimal number of - servers are compromised [OPAQUE].)

   Some applications may require learning the client's password for
   enforcing password rules.  Doing so invalidates this important
   security property of OPAQUE and is NOT RECOMMENDED.  Applications
   should move such checks to the client.  Note that limited checks at
   the server are possible to implement, e.g., detecting repeated
   passwords.

9.  IANA Considerations

   This document makes no IANA requests.

10.  References

10.1.  Normative References

   [I-D.irtf-cfrg-voprf]
              Davidson, A., Faz-Hernandez, A., Sullivan, N., and C. A.
              Wood, "Oblivious Pseudorandom Functions (OPRFs) using
              Prime-Order Groups", Work in Progress, Internet-Draft,
              draft-irtf-cfrg-voprf-06, 21 February 2021,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              voprf-06.txt>.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://datatracker.ietf.org/doc/html/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://datatracker.ietf.org/doc/html/rfc2119>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <https://datatracker.ietf.org/doc/html/rfc4086>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://datatracker.ietf.org/doc/html/rfc8174>.

10.2.  Informative References

   [AuCPace]  Haase, B. and B. Labrique, "AuCPace: Efficient verifier-
              based PAKE protocol tailored for the IIoT",
              http://eprint.iacr.org/2018/286 , 2018.

   [BG04]     Brown, D. and R. Galant, "The static Diffie-Hellman
              problem", http://eprint.iacr.org/2004/306 , 2004.

   [Boyen09]  Boyen, X., "HPAKE: Password Authentication Secure against
              Cross-Site User Impersonation", Cryptology and Network
              Security (CANS) , 2009.

   [Canetti01]
              Canetti, R., "Universally composable security: A new
              paradigm for cryptographic protocols", IEEE Symposium on
              Foundations of Computer Science (FOCS) , 2001.

   [Cheon06]  Cheon, J.H., "Security analysis of the strong Diffie-
              Hellman problem", Euroctypt 2006 , 2006.

   [FIPS202]  National Institute of Standards and Technology (NIST),
              "SHA-3 Standard: Permutation-Based Hash and Extendable-
              Output Functions", August 2015,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.202.pdf>.

   [FK00]     Ford, W. and B.S. Kaliski, Jr, "Server-assisted generation
              of a strong secret from a password", WETICE , 2000.

   [GMR06]    Gentry, C., MacKenzie, P., and . Z, Ramzan, "A method for
              making password-based key exchange resilient to server
              compromise", CRYPTO , 2006.

   [HMQV]     Krawczyk, H., "HMQV: A high-performance secure Diffie-
              Hellman protocol", CRYPTO , 2005.

   [I-D.irtf-cfrg-argon2]
              Biryukov, A., Dinu, D., Khovratovich, D., and S.
              Josefsson, "The memory-hard Argon2 password hash and
              proof-of-work function", Work in Progress, Internet-Draft,
              draft-irtf-cfrg-argon2-13, 11 March 2021,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              argon2-13.txt>.

   [JKKX16]   Jarecki, S., Kiayias, A., Krawczyk, H., and J. Xu,
              "Highly-efficient and composable password-protected secret
              sharing (or: how to protect your bitcoin wallet online)",
              IEEE European Symposium on Security and Privacy , 2016.

   [keyagreement]
              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.
              Davis, "Recommendation for pair-wise key-establishment
              schemes using discrete logarithm cryptography", National
              Institute of Standards and Technology report,
              DOI 10.6028/nist.sp.800-56ar3, April 2018,
              <https://doi.org/10.6028/nist.sp.800-56ar3>.

   [LGR20]    Len, J., Grubbs, P., and T. Ristenpart, "Partitioning
              Oracle Attacks", n.d.,
              <https://eprint.iacr.org/2020/1491.pdf>.

   [OPAQUE]   Jarecki, S., Krawczyk, H., and J. Xu, "OPAQUE: An
              Asymmetric PAKE Protocol Secure Against Pre-Computation
              Attacks", Eurocrypt , 2018.

   [RFC2898]  Kaliski, B., "PKCS #5: Password-Based Cryptography
              Specification Version 2.0", RFC 2898,
              DOI 10.17487/RFC2898, September 2000,
              <https://datatracker.ietf.org/doc/html/rfc2898>.

   [RFC2945]  Wu, T., "The SRP Authentication and Key Exchange System",
              RFC 2945, DOI 10.17487/RFC2945, September 2000,
              <https://datatracker.ietf.org/doc/html/rfc2945>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://datatracker.ietf.org/doc/html/rfc5869>.

   [RFC7914]  Percival, C. and S. Josefsson, "The scrypt Password-Based
              Key Derivation Function", RFC 7914, DOI 10.17487/RFC7914,
              August 2016,
              <https://datatracker.ietf.org/doc/html/rfc7914>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://datatracker.ietf.org/doc/html/rfc8017>.

   [RFC8125]  Schmidt, J., "Requirements for Password-Authenticated Key
              Agreement (PAKE) Schemes", RFC 8125, DOI 10.17487/RFC8125,
              April 2017,
              <https://datatracker.ietf.org/doc/html/rfc8125>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://datatracker.ietf.org/doc/html/rfc8446>.

   [SIGNAL]   "Signal recommended cryptographic algorithms",
              https://signal.org/docs/specifications/
              doubleratchet/#recommended-cryptographic-algorithms ,
              2016.

   [SPAKE2plus]
              Shoup, V., "Security Analysis of SPAKE2+",
              http://eprint.iacr.org/2020/313 , 2020.

Appendix A.  Acknowledgments

   The OPAQUE protocol and its analysis is joint work of the author with
   Stas Jarecki and Jiayu Xu.  We are indebted to the OPAQUE reviewers
   during CFRG's aPAKE selection process, particularly Julia Hesse and
   Bjorn Tackmann.  This draft has benefited from comments by multiple
   people.  Special thanks to Richard Barnes, Dan Brown, Eric Crockett,
   Paul Grubbs, Fredrik Kuivinen, Payman Mohassel, Jason Resch, Greg
   Rubin, and Nick Sullivan.

Appendix B.  Alternate AKE Instantiations

   It is possible to instantiate OPAQUE with other AKEs, such as HMQV
   [HMQV] and SIGMA-I.  HMQV is similar to 3DH but varies in its key
   schedule.  SIGMA-I uses digital signatures rather than static DH keys
   for authentication.  Specification of these instantiations is left to
   future documents.  A sketch of how these instantiations might change
   is included in the next subsection for posterity.

   OPAQUE may also be instantiated with any post-quantum (PQ) AKE
   protocol that has the message flow above and security properties (KCI
   resistance and forward secrecy) outlined in Section 8.  Note that
   such an instantiation is not quantum-safe unless the OPRF is quantum-
   safe.  However, an OPAQUE instantiation where the AKE is quantum-
   safe, but the OPRF is not, would still ensure the confidentiality of
   application data encrypted under session_key (or a key derived from
   it) with a quantum-safe encryption function.

B.1.  HMQV Instantiation Sketch

   An HMQV instantiation would work similar to OPAQUE-3DH, differing
   primarily in the key schedule [HMQV].  First, the key schedule
   "preamble" value would use a different constant prefix -- "HMQV"
   instead of "3DH" -- as shown below.

   preamble = concat("HMQV",
                     I2OSP(len(client_identity), 2), client_identity,
                     KE1,
                     I2OSP(len(server_identity), 2), server_identity,
                     KE2.inner_ke2)

   Second, the IKM derivation would change.  Assuming HMQV is
   instantiated with a cyclic group of prime order p with bit length L,
   clients would compute "IKM" as follows:

   u' = (eskU + u \* skU) mod p
   IKM = (epkS \* pkS^s)^u'

   Likewise, servers would compute "IKM" as follows:

   s' = (eskS + s \* skS) mod p
   IKM = (epkU \* pkU^u)^s'

   In both cases, "u" would be computed as follows:

   hashInput = concat(I2OSP(len(epkU), 2), epkU,
                      I2OSP(len(info), 2), info,
                      I2OSP(len("client"), 2), "client")
   u = Hash(hashInput) mod L

   Likewise, "s" would be computed as follows:

   hashInput = concat(I2OSP(len(epkS), 2), epkS,
                      I2OSP(len(info), 2), info,
                      I2OSP(len("server"), 2), "server")
   s = Hash(hashInput) mod L

   Hash is the same hash function used in the main OPAQUE protocol for
   key derivation.  Its output length (in bits) must be at least L.

B.2.  SIGMA-I Instantiation Sketch

   A SIGMA-I instantiation differs more drastically from OPAQUE-3DH
   since authentication uses digital signatures instead of Diffie
   Hellman.  In particular, both KE2 and KE3 would carry a digital
   signature, computed using the server and client private keys
   established during registration, respectively, as well as a MAC,
   where the MAC is computed as in OPAQUE-3DH.

   The key schedule would also change.  Specifically, the key schedule
   "preamble" value would use a different constant prefix -- "SIGMA-I"
   instead of "3DH" -- and the "IKM" computation would use only the
   ephemeral key shares exchanged between client and server.

Appendix C.  Test Vectors

   This section contains test vectors for the OPAQUE-3DH specification.
   Each test vector specifies the configuration information, protocol
   inputs, intermediate values computed during registration and
   authentication, and protocol outputs.  All values are encoded in
   hexadecimal strings.  The configuration information includes the
   (OPRF, Hash, MHF, EnvelopeMode, Group) tuple, where the Group matches
   that which is used in the OPRF.  These test vectors were generated
   using draft-06 of [I-D.irtf-cfrg-voprf].

C.1.  OPAQUE-3DH Test Vector 1

C.1.1.  Configuration

   OPRF: 0001
   Hash: SHA512
   MHF: Identity
   KDF: HKDF-SHA512
   MAC: HMAC-SHA512
   EnvelopeMode: 01
   Group: ristretto255
   Context: 4f50415155452d504f43
   Nh: 64
   Npk: 32
   Nsk: 32
   Nm: 64
   Nx: 64
   Nok: 32

C.1.2.  Input Values

   oprf_seed: 5c4f99877d253be5817b4b03f37b6da680b0d5671d1ec5351fa61c5d82
   eab28b9de4c4e170f27e433ba377c71c49aa62ad26391ee1cac17011d8a7e9406657c
   8
   credential_identifier: 31323334
   password: 436f7272656374486f72736542617474657279537461706c65
   envelope_nonce: 71b8f14b7a1059cdadc414c409064a22cf9e970b0ffc6f1fc6fdd
   539c4676775
   masking_nonce: 54f9341ca183700f6b6acf28dbfe4a86afad788805de49f2d680ab
   86ff39ed7f
   server_private_key: 16eb9dc74a3df2033cd738bf2cfb7a3670c569d7749f284b2
   b241cb237e7d10f
   server_public_key: 18d5035fd0a9c1d6412226df037125901a43f4dff660c0549d
   402f672bcc0933
   server_nonce: f9c5ec75a8cd571370add249e99cb8a8c43f6ef05610ac6e354642b
   f4fedbf69
   client_nonce: 804133133e7ee6836c8515752e24bb44d323fef4ead34cde967798f
   2e9784f69
   server_keyshare: 6e77d4749eb304c4d74be9457c597546bc22aed699225499910f
   c913b3e90712
   client_keyshare: f67926bd036c5dc4971816b9376e9f64737f361ef8269c18f69f
   1ab555e96d4a
   server_private_keyshare: f8e3e31543dd6fc86833296726773d51158291ab9afd
   666bb55dce83474c1101
   client_private_keyshare: 4230d62ea740b13e178185fc517cf2c313e6908c4cd9
   fb42154870ff3490c608
   blind_registration: c62937d17dc9aa213c9038f84fe8c5bf3d953356db01c4d48
   acb7cae48e6a504
   blind_login: b5f458822ea11c900ad776e38e29d7be361f75b4d79b55ad74923299
   bf8d6503
   oprf_key: 23d431bab39aea4d2737ac391a50076300210730971788e3a6a8c29ad3c
   5930e

C.1.3.  Intermediate Values

   client_public_key: f692d6b738b4e240d5f59d534371363b47817c00c7058d4a33
   439911e66c3c27
   auth_key: 27972f9b1cf2ce524d50a7afa40a2ee6957904e2bef29976bdbda452a84
   fcf01023f3ddd8182e64ea5287f99765dd39b83fa89fe189db227212a144134684783
   randomized_pwd: 750ef06299c2fb102242fd84e59613616338f83e69c09c1dc3f91
   c57ac0642876ccbe785e94aa094262efdc6aed08b3faff7c1bddfa14c434c5a908ad6
   c5f9d5
   envelope: 71b8f14b7a1059cdadc414c409064a22cf9e970b0ffc6f1fc6fdd539c46
   76775455739db882585a7c8b3e9ae7955da7135900d85ab832aa83a34b3ce481efc9e
   43d4c2276220c8bcb9d27b5a827a5a2d655700321f3b32d21f578c21316195d8
   handshake_secret: 02fb23a668b7138b029c95d21f1e0eec9e10377be933bdbf3e5
   33ea39073d3ce9d1ef16b55a8a8464f3bf6a991cc645d14c1fa3d9d6cfe36c6c0dcc2
   691d7109
   server_mac_key: e75ce46beeebd26f22540d7988de9809a69cf34fec6c050750708
   e91232297fdbb51e875cd37167d5ce661ebccf0004dbbf96311daf64ddec7faae04c4
   8bbd89
   client_mac_key: 4bce132daa031fff2a6e5ac29287c4641e3b9dc2560394b8c73f3
   b748f1e51e577b932a960b236981217b33bee220b0bce2696638cfb7791f427ade292
   d60f55

C.1.4.  Output Values

   registration_request: 80576bce33c6ce89f9e1a06d8595cd9d09d9aef46b20dad
   d57a845dc50e7c074
   registration_response: 1a80fdb4f4eb1985587b5b95661d2cff1ef2493cdcdd88
   b5699f39048f0d6c2618d5035fd0a9c1d6412226df037125901a43f4dff660c0549d4
   02f672bcc0933
   registration_upload: f692d6b738b4e240d5f59d534371363b47817c00c7058d4a
   33439911e66c3c2795014d8fc0c710bd763c981c5b9329c95e149c6717af91bad2cec
   daf87f2c3c9c11914cb6d44aaee5679e3e61e1b65241fda74902cca908a065495c0b2
   8b799e71b8f14b7a1059cdadc414c409064a22cf9e970b0ffc6f1fc6fdd539c467677
   5455739db882585a7c8b3e9ae7955da7135900d85ab832aa83a34b3ce481efc9e43d4
   c2276220c8bcb9d27b5a827a5a2d655700321f3b32d21f578c21316195d8
   KE1: 60d71c9f5d2a14568807b869e2c251a8e5f7ad8951cd8386c7e32c0634b26b16
   804133133e7ee6836c8515752e24bb44d323fef4ead34cde967798f2e9784f69f6792
   6bd036c5dc4971816b9376e9f64737f361ef8269c18f69f1ab555e96d4a
   KE2: 78a428204f552d3532bad040c961324edb22c738d98f1dd770d65caba0bd8966
   54f9341ca183700f6b6acf28dbfe4a86afad788805de49f2d680ab86ff39ed7fbcbbb
   84a18810b8eb1dc898d9af686f5901a21d0768720b325279fde4931ee52f0d4a0d0d9
   cd1cd7c424d4622b1588ba554cd9241352a59ef52bbe85e0f865021404b115ba954f5
   540cf2d811a6566a93876cac1239b1f75f39b070250af5a84a819e08b13e9e437a80f
   c25cc130f8475dde43efe6d900c664e9bac300298bb0f9c5ec75a8cd571370add249e
   99cb8a8c43f6ef05610ac6e354642bf4fedbf696e77d4749eb304c4d74be9457c5975
   46bc22aed699225499910fc913b3e907120485942e3e077f71c1dd2d87053b39f0d31
   bfe5d5f90df0e85ad9ce771e4f4d1ab697a10a02002cd73916051b887da9554465d58
   68811fd8b22b8f457ed5a4b0
   KE3: b4f8aece9fb4f6b7b5ffe1c98747a91f4ec7bf5481fe5719ba4baad668e3fd4e
   8aba4fa227bd4c688ed9e17f6c6d28ab5e5617a883207d80979dc4797ca89304
   export_key: 045f61f4baa0a945c2e85dfb7a85fe4df8a49e6c31344920e863c286b
   c8a17fe25fc16c84836335b4b5ecc9743c5d3a221101ab004aa99ce65026b6953ad6c
   c0
   session_key: 91187690e5ea0da3110a1dd7d5ffd7c4c3111950c587d9fcf3b9f34b
   f73b86dbeafed42a05024fa875a32415c6143d20c39cd732eb0e31db5e60ea3fb2551
   cf7

C.2.  OPAQUE-3DH Test Vector 2

C.2.1.  Configuration

   OPRF: 0001
   Hash: SHA512
   MHF: Identity
   KDF: HKDF-SHA512
   MAC: HMAC-SHA512
   EnvelopeMode: 01
   Group: ristretto255
   Context: 4f50415155452d504f43
   Nh: 64
   Npk: 32
   Nsk: 32
   Nm: 64
   Nx: 64
   Nok: 32

C.2.2.  Input Values

   client_identity: 616c696365
   server_identity: 626f62
   oprf_seed: db5c1c16e264b8933d5da56439e7cfed23ab7287b474fe3cdcd58df089
   a365a426ea849258d9f4bc13573601f2e727c90ecc19d448cf3145a662e0065f157ba
   5
   credential_identifier: 31323334
   password: 436f7272656374486f72736542617474657279537461706c65
   envelope_nonce: d0c7b0f0047682bd87a87e0c3553b9bcdce7e1ae3348570df20bf
   2747829b2d2
   masking_nonce: 30635396b708ddb7fc10fb73c4e3a9258cd9c3f6f761b2c227853b
   5def228c85
   server_private_key: eeb2fcc794f98501b16139771720a0713a2750b9e528adfd3
   662ad56a7e19b04
   server_public_key: 8aa90cb321a38759fc253c444f317782962ca18d33101eab2c
   8cda04405a181f
   server_nonce: 3fa57f7ef652185f89114109f5a61cc8c9216fdd7398246bb7a0c20
   e2fbca2d8
   client_nonce: a6bcd29b5aecc3507fc1f8f7631af3d2f5105155222e48099e5e608
   5d8c1187a
   server_keyshare: ae070cdffe5bb4b1c373e71be8e7d8f356ee5de37881533f1039
   7bcd84d35445
   client_keyshare: 642e7eecf19b804a62817486663d6c6c239396f709b663a4350c
   da67d025687a
   server_private_keyshare: 0974010a8528b813f5b33ae0d791df88516c8839c152
   b030697637878b2d8b0a
   client_private_keyshare: 03b52f066898929f4aca48014b2b97365205ce691ee3
   444b0a7cecec3c7efb01
   blind_registration: a66ffb41ccf1194a8d7dda900f8b6b0652e4c7fac4610066f
   e0489a804d3bb05
   blind_login: e6f161ac189e6873a19a54efca4baa0719e801e336d929d35ca28b5b
   4f60560e
   oprf_key: 1e0550d2dbb9ce5dd9bdbb5f808afbb724c573dc03306dcfc7217796465
   ce607
   fake_client_public_key: 04424c7507958b2504dd71c4df1f9f4eae1f2b5386e2d
   81943e99c8d43e4c56c
   fake_masking_nonce: c6d04efaee8370c45fa1dfad70201edd140cec8ed6c73b5fc
   d15c477408184fa
   fake_masking_key: 983deeb54c9c6337fdd9e120de85343dc7887f00248f1acacc4
   a8319d50e29b581d716c3c05c4a0d6110b510cb5c9959bee817fdeb1eabd7ccd74fed
   55bb1214

C.2.3.  Intermediate Values

   client_public_key: ba6cb41f1870e9db7e858440a664e6559d01fdbfb638bbf7e1
   c9004f20d5db71
   auth_key: 5142ae6f6bd80686039656fd7a03cdd7e39cc6e869aa637220d4b5fb64f
   afee2f284a1581fff95ad3a5261b413c5e5b91115f78a3c35486fa56023c300d1726b
   randomized_pwd: cea240b632b9c1d704034920cc3dc3c664ed8cd82cf5c0339af76
   4d6350d2ee9ba1f675ce8df7b6cf8692d1efb158bafa3c2695ac03a2d92346c19810c
   1a698b
   envelope: d0c7b0f0047682bd87a87e0c3553b9bcdce7e1ae3348570df20bf274782
   9b2d26e18240c0cbad3b4cdbd7d9d86512f87e43fac39e3785a17504aaa8508f81e3c
   1517b150259be478720935e175b1e34bbe625d0828a62ca9983f9a27aed27f5e
   handshake_secret: 7925c12d7bf3050e62fe5c8caaece3c85737754c5df79bc59a6
   0fa87929ab1f4a4730f903b87be8b7d89ded8ec97aaec97bc8e7d53a555fd4ad74c4f
   33b9bc83
   server_mac_key: 27d6036335c5654132fb08cc81d95b3067ef7fe795f017531231a
   e3fa03cd3ab72f1f5e81473318f9c01f990263d885dfce4b6ac8630fdc8ee8abc6a36
   7c2339
   client_mac_key: ebb3693bac6310075a89922c7a40599d14d03d9104b7a331106e8
   a578a32a4944751f9d3c230a6690a5747137388a86159cf587969d13dadc0a3830218
   dfbca5
   fake_server_mac_key: 244367da7aaf1c0e8258e21adc6bdce3fe968b4c32692be7
   0572a83d2b934b607db312a0b7b11c509b5efb347e9dd10c3ccaa4fe53133751c1b09
   f53884c9687
   fake_client_mac_key: 5c807ae6ce7fdca4060c115dce34927cc5aa21c03f1e144d
   824773a7859f981645e62d82dee55823c3695e81c55250af2ac8de86b37dd4d44aa03
   04e8439201e
   fake_handshake_secret: b254b8f29ad3db178cbc40678ac6ff33de19681337cb2e
   be5b89fabcca63d379a736d884344652e83618d508ba22550ec02a64ffe780e9b2bbd
   9513c80a11268

C.2.4.  Output Values

   registration_request: f841cbb85844967568c7405f3831a58c4f5f37ccddb0baa
   4972ea912c960ae66
   registration_response: 0256257cc6e2b04444edc076b9ad44d8b31593e050bea8
   06485707a818f8a93f8aa90cb321a38759fc253c444f317782962ca18d33101eab2c8
   cda04405a181f
   registration_upload: ba6cb41f1870e9db7e858440a664e6559d01fdbfb638bbf7
   e1c9004f20d5db71146e42585d25fa19913876edce4b5ee99b638eb37b1d8a8a76607
   efaa12299e828641ba4fbf1c46fc2c3776e0a0c9791f88a15b9ddfb5495d63ce92d8f
   58823bd0c7b0f0047682bd87a87e0c3553b9bcdce7e1ae3348570df20bf2747829b2d
   26e18240c0cbad3b4cdbd7d9d86512f87e43fac39e3785a17504aaa8508f81e3c1517
   b150259be478720935e175b1e34bbe625d0828a62ca9983f9a27aed27f5e
   KE1: 14cc586d982b6db9846c78e0b3c543591e95fbf2fc877fa0e5eff89897dd3050
   a6bcd29b5aecc3507fc1f8f7631af3d2f5105155222e48099e5e6085d8c1187a642e7
   eecf19b804a62817486663d6c6c239396f709b663a4350cda67d025687a
   KE2: 8ab71c17547f376ae787741c367142790087090cdde6327dabb2581197bffa59
   30635396b708ddb7fc10fb73c4e3a9258cd9c3f6f761b2c227853b5def228c85dd973
   a1ac59244f674da4a1c057961886661bd29e0c1346f0fcf75bf1c78d4781815c2f9f6
   f2f9fe0e370b256f6e82fb2e14c7ffc374d42caf26abf13dca169a6faafd5cff8baa9
   717090bc1fc5e1ba56acb93492d1a8b789f33ff29b6004c4be9a755ff590d7d00d6e8
   893e7e54e639aebf69d18f2182a9bb0f2e1c27c81ba73fa57f7ef652185f89114109f
   5a61cc8c9216fdd7398246bb7a0c20e2fbca2d8ae070cdffe5bb4b1c373e71be8e7d8
   f356ee5de37881533f10397bcd84d35445401c619d464ab3a134c71da4d9874f2f736
   189b8bbb659c28f8db25a58b9f089272132e3091efa87d6b07d10321ba464047be011
   3e91514aba299fd1553bcebb
   fake_KE2: 42b939dd3973da2118675c3d73c27bb727f547929087b1a3f7fae275774
   5de3ac6d04efaee8370c45fa1dfad70201edd140cec8ed6c73b5fcd15c477408184fa
   9bfd14cd257ab27502fe054e791fd6e63542a4b7c5eb464a871e03ed5c114a5f72f34
   d0be241e72092fd832bf4b28089ff98843543b9c61d39be148a76047379eee4f3d71b
   836381db9c131e2f92e8da2540f9675f401f8b3b5498aeca54c2bb410c77833259884
   f8147cf619c04ac250d670c6803172288b6cf44e0376beaa83fa57f7ef652185f8911
   4109f5a61cc8c9216fdd7398246bb7a0c20e2fbca2d8ae070cdffe5bb4b1c373e71be
   8e7d8f356ee5de37881533f10397bcd84d354458f6feffa7c9fc119d1685a1b6b19c6
   9b37bd1494c623e24e569dc64aa56601275a5ef70b56768f931df368061eb1e31dff1
   be0542040f2e92f1bc9d2748d5578
   KE3: c4a0d5b8148f3ac0f8611b38de38bda085d4eb00d561397ae59676f36dc705be
   1c939e7bfdd7301103af5eb164bdfb70298aab889bd2ac797e419a82bfb442e6
   export_key: 6b50ae4dba956930c0465b4a26c3cee58e05afcab623c1c254ae34acc
   38babf954530a53475672ff46a1cf7fd53ef9e808f85b08793d021bb5c6d2a1bb9204
   f6
   session_key: c9bc2b7e2237f6fbeccd92dc6ec6d51faeb886492f8d23f21743a967
   597025215df02a4afb75349acbafeef9dfd4f19e6d38da8bea4912f7b691b70849b0d
   78e

C.3.  OPAQUE-3DH Test Vector 3

C.3.1.  Configuration

   OPRF: 0003
   Hash: SHA256
   MHF: Identity
   KDF: HKDF-SHA256
   MAC: HMAC-SHA256
   EnvelopeMode: 01
   Group: P256_XMD:SHA-256_SSWU_RO_
   Context: 4f50415155452d504f43
   Nh: 32
   Npk: 33
   Nsk: 32
   Nm: 32
   Nx: 32
   Nok: 32

C.3.2.  Input Values

   oprf_seed: 2916911a3d9b80a9380d78c283bf98e26334038293e47865922a3b54d3
   722d8e
   credential_identifier: 31323334
   password: 436f7272656374486f72736542617474657279537461706c65
   envelope_nonce: 7012c76c332cdb5ba994c5c01c1855151c467aa331d70f59d9bb6
   3e9afa1e314
   masking_nonce: 4d77dab871872dba848bdf20ed725f0fa3b58e7d8f3eab2a0aace2
   61f61193c7
   server_private_key: 78bc1edbaf79bee4cd28dd9db89179dcc9219bc8f388b533f
   54390985abe5f7f
   server_public_key: 03ace73b71d758319d2afe6d27d905f1ab00493cba0e4bf011
   4762b285b938c43a
   server_nonce: a17ab9c688c0bd231ec85e55de90b7d0b16385659d1b4a2697a5327
   6c728ebf4
   client_nonce: 7239f8fe6f1be88972721898ef81cc0a76a0b5508f2f7bb817e86f1
   dd05ca013
   server_keyshare: 02d8b7975778ff4e95808dd698b7b19544a9555312e6ad077171
   cedf3c4856f3cb
   client_keyshare: 03845043cc460779d3d868894fd28dcf4a0814e6fdd7b87769e6
   d4ba4c477df6e7
   server_private_keyshare: 2ea37c7e4a0f9f1984ff1f2a310fe428d9de5819bf63
   b3942dbe09f991ca0cf6
   client_private_keyshare: 4c3ad31f016b68085d25f85613f5838cd7c6b1697f27
   bb5e8018e88ecfc53892
   blind_registration: 672a9c7c6e460d5d7b5d31d5e3ebdb127f92416a3cbcda76e
   24b2be8d08c7908
   blind_login: 190a68602c7af25f47401b35db40bdc28cd90b502b3390d3cfea5814
   c105ca7c
   oprf_key: f9bbc90b346a43b958f94151d0855a98bccafaf09637a041f2a31784a14
   669ac

C.3.3.  Intermediate Values

   client_public_key: 0351ae26aae1317a01ccb6f377f0b84b17910b49c0453e072c
   a335dd2fde35a80d
   auth_key: 4e611c40f25d26203fbc5985695f66eb16bc8bd3415fbdafc90271d6b8a
   9fde3
   randomized_pwd: 13727b13dd8bdaca93a3da91460aa8927a10cc874b72588d98d79
   5b5906451bf
   envelope: 7012c76c332cdb5ba994c5c01c1855151c467aa331d70f59d9bb63e9afa
   1e31471ea0e5f53d1a3af8d02a6048d638231de33c691e7d5272495f1fe990747003d
   handshake_secret: c7914289ff3e9a017e469fbfa8fc9af1ed2d475c7af6ed9e25f
   c0132c2e19397
   server_mac_key: 6dfde98fa03dd7d88d580752242b2d284be6b646bee2158f82283
   d3ff9cc5fd1
   client_mac_key: 4b280deb4fd29a8d1bbf65d334764976af627c0396d2263a7f4dc
   b54901c2d0f

C.3.4.  Output Values

   registration_request: 03aa52e300361a69b2ea105772c5276d256f575111bc642
   caf914f14098334fa24
   registration_response: 02bf3b64856d61b950f4a98909cd777663c7a181328156
   c4b742d69119065a88a403ace73b71d758319d2afe6d27d905f1ab00493cba0e4bf01
   14762b285b938c43a
   registration_upload: 0351ae26aae1317a01ccb6f377f0b84b17910b49c0453e07
   2ca335dd2fde35a80d6332e4f22d769b5f8829e4589e13c6bb9b4ebeea1024a85f17b
   e7fbe8b33697b7012c76c332cdb5ba994c5c01c1855151c467aa331d70f59d9bb63e9
   afa1e31471ea0e5f53d1a3af8d02a6048d638231de33c691e7d5272495f1fe9907470
   03d
   KE1: 03cf4ddc3250f7bdd1b84da71a8712acec630ccbe04add9f3c7c59659edbda6d
   c57239f8fe6f1be88972721898ef81cc0a76a0b5508f2f7bb817e86f1dd05ca013038
   45043cc460779d3d868894fd28dcf4a0814e6fdd7b87769e6d4ba4c477df6e7
   KE2: 03e0adebaddee2e1dafd8ded8412bb59cdda19bc515589e467adaa2891830e64
   6d4d77dab871872dba848bdf20ed725f0fa3b58e7d8f3eab2a0aace261f61193c71d5
   821f9411a66cf6547ba4ae4923d33e4095793217f0df5731a9f0918778fcc98e7609b
   9952ccbfaef3a3f20283768c95c4ea86fc5ee9dcd0e4e84741564546332f95527a7ec
   4261ea836a22d7c24439588d75bc67cfaabcc77cc6f4c64df7feea17ab9c688c0bd23
   1ec85e55de90b7d0b16385659d1b4a2697a53276c728ebf402d8b7975778ff4e95808
   dd698b7b19544a9555312e6ad077171cedf3c4856f3cb5501789bbe5f5c600418aa01
   4cd89bf61ed22279914b9f5009f8c1e6d1bcd6ca
   KE3: fdd1a06dfda435ca6b76b13f3225e59cc1b641ed91d439842c6dda4e79643112
   export_key: 31f615fddce62f659b9a7549bb014c5c03338a7a17bc1bc77433a419e
   014751b
   session_key: 137df86dddd7358c51bd9a178e85c597f86f911ab039702ef2567f2a
   48c7e6ed

C.4.  OPAQUE-3DH Test Vector 4

C.4.1.  Configuration

   OPRF: 0003
   Hash: SHA256
   MHF: Identity
   KDF: HKDF-SHA256
   MAC: HMAC-SHA256
   EnvelopeMode: 01
   Group: P256_XMD:SHA-256_SSWU_RO_
   Context: 4f50415155452d504f43
   Nh: 32
   Npk: 33
   Nsk: 32
   Nm: 32
   Nx: 32
   Nok: 32

C.4.2.  Input Values

   client_identity: 616c696365
   server_identity: 626f62
   oprf_seed: 344022969d17d9cf4c88b7a9eec4c36bf64de079abb6dc7a1d46439446
   498f95
   credential_identifier: 31323334
   password: 436f7272656374486f72736542617474657279537461706c65
   envelope_nonce: 6d002be476bd06c756aee97ba2912bab9b6a62cddf7d5e3209a28
   59e5947586f
   masking_nonce: 0051724f14d71ff13ba5add017512cce702800f4272cdae1976cbf
   bdfd6ba61d
   server_private_key: e206269fe3eabd2b6e928b97b901c4819a3e89f48f9a72f09
   280e203ef27d9f0
   server_public_key: 029d85e73c0d1baf39018a3f1fb0623ffa1fb680ab4cdc05bd
   85ef66a10c7e833d
   server_nonce: a3cd7e6f042429c7c9e946f5351292fa08f4e99e395c30a95b268f2
   a077aa6fb
   client_nonce: 1f4b263b2b18c85bc0154de4711c04899739c0620dc94323d026011
   ac6def373
   server_keyshare: 03be9887a3d081ac60f58bd1cf1dfe62acd21f35a851250e05d0
   c149cbd1af2221
   client_keyshare: 028f511e5053fc9f3da9531703414583e38f9dacc95d458b6ccb
   051c1733518128
   server_private_keyshare: 834484836667b5ffb0ecf900c07c55d70e9894af0231
   f52c54dd29cccdae5faf
   client_private_keyshare: 34760c02e2a29e6b9c9e71ee3143a236fab399496558
   80d88538d3efb0b85e9d
   blind_registration: 69259e0708bdfab794f689eec14c7deb7edde68c81645156c
   f278f21161e3aab
   blind_login: 8cc6b69daac7a90de8837d49708e76310767cbe4af18594dfcd43621
   6c265831
   oprf_key: 7469545f78884064a541f1f2e8be5a8b23dba6dbfa13b909074b9c87a2c
   16d98
   fake_client_public_key: 037cca183c9cc3f58d8b966a8f1f09916c2f7a10f1e53
   466bb60ce265d969b5c5a
   fake_masking_nonce: ff3d09c6af9912a1e231e96cb38425b7f9465ff5f824ef4d3
   4c3e410f944408b
   fake_masking_key: a8c72a8ff433f9df64ca57d76124b27cd1a1cf0c75e843b4c26
   bffbeecde0384

C.4.3.  Intermediate Values

   client_public_key: 03d8278c96f419db6dcc68b833ef2c6b55ab94bc6f2b6d44c3
   e43ca6d27fbfcec5
   auth_key: 58ee7e89b64ee2a23c268e6340799cd5fe8b301e1e64cd08f9ae2cdceb0
   d9704
   randomized_pwd: 23e97563c2d1d77c7bac265cb7fa0291974ea499a2b5fa58444c9
   ed8f0f81d67
   envelope: 6d002be476bd06c756aee97ba2912bab9b6a62cddf7d5e3209a2859e594
   7586f9a6dd329d982d81a042f91fe3eddf0cf9e40587915e32d342181b647eefc68dc
   handshake_secret: a01521f01e6e527fa73344df7f433bea74770f1b6d528924336
   c6924810a0183
   server_mac_key: aaae135e69a7fb1fc533c0ff856bf106eeaaf762980df2e76f4cf
   6ebdeb0cd7c
   client_mac_key: da982d2dc5b9b421536f4a70c713735752154d8a255557aa92483
   b3b6074ed94
   fake_server_mac_key: c061cab5449a728629d51f5acff2509fb81da84a63ca9721
   d76375f23582ecd1
   fake_client_mac_key: 32b8c91dffe11fdd7f247187c2401ae7427bb9bd7888b4c1
   5aca01a3d03873a4
   fake_handshake_secret: 61f32486f60865bdb28e7379234ffc27ab16bb5aebafa8
   7577799b14a5709319

C.4.4.  Output Values

   registration_request: 025ecc70dabfc2a2334c75b911dee11ce1a1eacbf008725
   2a2cd0eccc9e6f60b26
   registration_response: 024a6a6566932abeb4e915d2e08d4373780dd7579f50a1
   9893aa6c8f194bba5004029d85e73c0d1baf39018a3f1fb0623ffa1fb680ab4cdc05b
   d85ef66a10c7e833d
   registration_upload: 03d8278c96f419db6dcc68b833ef2c6b55ab94bc6f2b6d44
   c3e43ca6d27fbfcec591240de9ebfe38a110dd2e279135a56d20b1a73ebd6df571525
   9ccd3bea95b296d002be476bd06c756aee97ba2912bab9b6a62cddf7d5e3209a2859e
   5947586f9a6dd329d982d81a042f91fe3eddf0cf9e40587915e32d342181b647eefc6
   8dc
   KE1: 03c05560177607a89857f0e8c722aeb1bc554a3e66a9ac5f48e6aa8fc61a3469
   b91f4b263b2b18c85bc0154de4711c04899739c0620dc94323d026011ac6def373028
   f511e5053fc9f3da9531703414583e38f9dacc95d458b6ccb051c1733518128
   KE2: 036c833dfbe70430a6e846b8a4edf6a45e9f0ba68f6d4990e988565952899c6f
   630051724f14d71ff13ba5add017512cce702800f4272cdae1976cbfbdfd6ba61d277
   8c4288abd7cf39467778b8a1a17f85d76f816be4c897784f452140f1b8095e9387c91
   86a68f9acb0473d68ad60b7b79b512fe25dcda01e3e8082a2a5d3fa733d2d426f5478
   89578016b077c55dc2280b5c3258bca5232ca98b0096591536273a3cd7e6f042429c7
   c9e946f5351292fa08f4e99e395c30a95b268f2a077aa6fb03be9887a3d081ac60f58
   bd1cf1dfe62acd21f35a851250e05d0c149cbd1af22213a98aeafe00c64858b4df6a5
   49eb66dc4590710d3aaa5edcc746f126c0468919
   fake_KE2: 035ddaeaa5c04775dbd89c092adb842ca5ec1ff6d737bcf15425c2b9ebb
   f45e1b2ff3d09c6af9912a1e231e96cb38425b7f9465ff5f824ef4d34c3e410f94440
   8bf2c726724d07d054b1238c1babf961534092d9e87be21a8371d9093cee58e1e7164
   699736cc5216d52d19c9491ce32345ef9957a62333bfc2efd5c7af0f608e693254519
   0681a038b2ed27c64c0bbb8c4484f2332f6f151e7482c7938dcd523e99a3cd7e6f042
   429c7c9e946f5351292fa08f4e99e395c30a95b268f2a077aa6fb03be9887a3d081ac
   60f58bd1cf1dfe62acd21f35a851250e05d0c149cbd1af222134cad7aef4ce8d6c09f
   e935d628e98da22f737fafa7916f66d4c485c0cfb0dff
   KE3: c7973842ded41ddce9ba206da6cf43e5d166674d6e2cd0d63068e732c82e43f1
   export_key: 2ced1639c9bf7b59cfe6631a0be55a45a99e6efca404f0ddd6ff278f4
   0ecd176
   session_key: 6d9a4dbe9b5aa620f1c3828f2eab61b442d71423de8c3a1578c803c6
   af547b64

C.5.  OPAQUE-3DH Test Vector 5

C.5.1.  Configuration

   OPRF: 0001
   Hash: SHA512
   MHF: Identity
   KDF: HKDF-SHA512
   MAC: HMAC-SHA512
   EnvelopeMode: 02
   Group: ristretto255
   Context: 4f50415155452d504f43
   Nh: 64
   Npk: 32
   Nsk: 32
   Nm: 64
   Nx: 64
   Nok: 32

C.5.2.  Input Values

   oprf_seed: c35e1a3f4b5e0366c15771133082ec21035ae0ef0d8bcd0e59d26775ae
   953b9552fdfbf2ab6f469f2f153f9a88aacb7ed434aed9fd7ac1ab67bab00e8e9f1d4
   e
   credential_identifier: 31323334
   password: 436f7272656374486f72736542617474657279537461706c65
   envelope_nonce: b4a55e4c54231cc62c3542a08837b6c0709160251cbebe0d55e44
   23554c45da7
   masking_nonce: 8ce14142741e463c1441c8d7cae1f4fee4ee4ba509fda550ea0421
   a85762305b
   client_private_key: 497a94f3a81f9a88008bc0d9893e1dc5b270ee98d65be148e
   379d86a91a37503
   server_private_key: d3ea6fc257303f388140e5bbbcbf64972b563b26a64ae7139
   324890caefc970f
   server_public_key: eed559f5a580c651a23b954228768e7fdc379c3e41f0a7f96d
   dfc686a994c46c
   server_nonce: b8bb2700cdd47e339d95404519f2fb3da58c93d84cbb4d51de6757a
   31919382b
   client_nonce: 94384ca183c8e6f639ab29b5d2a81ef4305df9a67cb33db5ba8082e
   4f4bfb830
   server_keyshare: 34ade1bc39fd1cc690b3be07c161df452ccd68eae7fd52ea5427
   605dce674476
   client_keyshare: eaade685af670e0c72d0368b9c62940853ec0a1fa82eb3501d8c
   d15b5f24f811
   server_private_keyshare: 5f45be89ae4f66f7c6ba20001fe0f3ab2e4379cc955f
   fdf8832fefe312343f0d
   client_private_keyshare: cf240d9f6e55a3efb489e8e55691eacfa2980bc0807b
   d327239b53f4c641b603
   blind_registration: 31891ae8f0eb54797e29ca06c08d9f97d08f766fa7db7a078
   388be15129bd50e
   blind_login: 91be6cd547f203228e1312f577400a6c38a626fff407996caefbc469
   4a8a2a0e
   oprf_key: 3ae4f1b0e09300d8ef70636dc4b54081470c9c85449c4ba828f2749e19a
   77e01

C.5.3.  Intermediate Values

   client_public_key: 240ef1202b169ecf82d8c5a9f925bab893e030fd9e808b498a
   e414ea58cd7b4b
   auth_key: 6c200529067e8f79ec47f0288d3ce9a11d0e3231bd888e3dd9d4ff9e81c
   a2ebeb6c536085e5cb9038dd4068a96764156a2ea098f8f7a61962485474cc7a1e3f7
   randomized_pwd: 5162e5db3b453e56337006a83f74a7ff19773692d6abf39a8ea5b
   d3eed251c21ca0121972bc4c13ca53e98951a1467a8c4d0bf7d70facd66aa15ae5ade
   ea43d0
   envelope: b4a55e4c54231cc62c3542a08837b6c0709160251cbebe0d55e4423554c
   45da7e2c49570fac2aef6c6e8390eaecd615cbe0733193852d2ce04e0838d5d901c3c
   78e73935f15583c2c81e4900a23902a159bce4e3640e56c2d91119effbe34a1022973
   a9a16c523a87a7752e58d10f7b52ab7400ed0989f151ac34b18fa02f1bb
   handshake_secret: 33b931bec4e1b1e0361c90a2e00e9852cb7377d5c1b7481e9f5
   c39eafbd5a76ed3206137083ed68ce52775784981be4af72b197489bb644309f3367e
   b1d87a85
   server_mac_key: 2a3f3021c1956fb2797f44ce2cb7f707af4baf4a471eb68088040
   de2f8982b2cfbb15da148cc7cc935349d33d3ed44a3d8dc092156f1347c030e47e476
   d1192a
   client_mac_key: fe58ebd527de823c99c535a521e8f4344f1db7274df234badf382
   deed54c6a04aea004d8831aaa300216b6d84c4e19245cc932443ff9e8f30703dd97ef
   71ad64

C.5.4.  Output Values

   registration_request: 4a5eca0c07dd14899625426a599f45905837ff8574c754e
   ff300180e04edbf3d
   registration_response: 14bb2247e44257ff94e4da23d05fd02e305f19ca917b87
   18ba6840eb96b2b17deed559f5a580c651a23b954228768e7fdc379c3e41f0a7f96dd
   fc686a994c46c
   registration_upload: 240ef1202b169ecf82d8c5a9f925bab893e030fd9e808b49
   8ae414ea58cd7b4b7278710fd81b3c076d8296e4856cc40ea99db100404af3cf64051
   381eaab59a373d140e23fa623e0c8b2aeffc07988c798a9b0bf179a7ce90b3f5f503f
   1e3454b4a55e4c54231cc62c3542a08837b6c0709160251cbebe0d55e4423554c45da
   7e2c49570fac2aef6c6e8390eaecd615cbe0733193852d2ce04e0838d5d901c3c78e7
   3935f15583c2c81e4900a23902a159bce4e3640e56c2d91119effbe34a1022973a9a1
   6c523a87a7752e58d10f7b52ab7400ed0989f151ac34b18fa02f1bb
   KE1: a0e5ad070d68938cb5474f5501278a1d57b4f7ddf9c495b10753ff9e1cb46224
   94384ca183c8e6f639ab29b5d2a81ef4305df9a67cb33db5ba8082e4f4bfb830eaade
   685af670e0c72d0368b9c62940853ec0a1fa82eb3501d8cd15b5f24f811
   KE2: 60a59a8e0a5c8b19115637ab8e307a8817ee0bdb36c40356884f412518a3d73d
   8ce14142741e463c1441c8d7cae1f4fee4ee4ba509fda550ea0421a85762305be2984
   cc171eeba510dacf88460670a20de692c6ee67db9d98abe66bfccdcf1a13c65b14292
   a860d7c50787693af64a75abf9c4e566c9ab99a12881f68ecb129602e012b32f67c59
   6ae00f35579da0d397e657fca55bd6fb61cea2cf97f5f15bbdf92f8f230dd55b64536
   794d08c36a475e246c9902b7a85d90595e0469ad746f95160e290c5b69470284aafb6
   ecb5119a198f1d885710eca166f002c201b31fbb8bb2700cdd47e339d95404519f2fb
   3da58c93d84cbb4d51de6757a31919382b34ade1bc39fd1cc690b3be07c161df452cc
   d68eae7fd52ea5427605dce6744760a86fcec30ae2843921e3fc26fee5209a6fa7eb5
   b4809b7221575b966f44263cb7cb993023c3d92e1515878e8e5fa3447bde2a442cdc3
   f9503975bf4032dcb47
   KE3: 48a971c23179623551d08aa73bdbab14c8d5203b1133f13309dbb6553b6e4afd
   bd66f4bfb62d3118244d56f26710db5baecb8ef5d35cc4c559e77599e2470814
   export_key: 81c31a16e138f9a1299d078d3e560bc16b863f37b1b3d1f1eee5f04a4
   64045651d0f9296cffe4759681580bd078ef7b238ba9fe20f0c5c1f13717ce68644af
   4b
   session_key: c7dcbabb52c367585a4a05cc403d3698dbed85dff5432caa84dcc539
   3bb60ece53bcadf15e31008b40f17f357392ddd40004c8c01934b46406f3d5fa87586
   657

C.6.  OPAQUE-3DH Test Vector 6

C.6.1.  Configuration

   OPRF: 0001
   Hash: SHA512
   MHF: Identity
   KDF: HKDF-SHA512
   MAC: HMAC-SHA512
   EnvelopeMode: 02
   Group: ristretto255
   Context: 4f50415155452d504f43
   Nh: 64
   Npk: 32
   Nsk: 32
   Nm: 64
   Nx: 64
   Nok: 32

C.6.2.  Input Values

   client_identity: 616c696365
   server_identity: 626f62
   oprf_seed: 6745415fe147f60270fc68fd0990c1fd9b34b9187adfc0b6e485f8fc6a
   b6fea7ba0438613acde5a926bf796e5e24e879ebb50b60b2569a3cefa279126183be8
   b
   credential_identifier: 31323334
   password: 436f7272656374486f72736542617474657279537461706c65
   envelope_nonce: 072d4eccf379adfb08f7f8ec28aadd14a78b68466e51a251d1329
   9f10df28595
   masking_nonce: 8d3346ca21d8a6439465aea2b4b54c1d109bc5ea6819cd5cca28ea
   3ed382a155
   client_private_key: 894a0631fa4902b7fbbf1c2f9708e257b48354f38b6ac4713
   71fbcf685c49400
   server_private_key: 8db58214776fab66d8bd2070dbb71f82f81e1a3c8ce277df3
   0ab5f4614b9310f
   server_public_key: c8f1aa3505a35c276fd5e490d338dbbe51f762bc553b3b71e9
   38d3ff57d97d4a
   server_nonce: ad275c32713d314a14cd58a6466cfb980f9a2604c25d83d1a98a387
   17e97bfde
   client_nonce: 679eb9edc4b8943b0ffbe09577ecdb625726cb333292ebc7c8a8c93
   3f0fc9800
   server_keyshare: dc2e6e45d4138be457e0c1ae504de25440922f5d127574282b7f
   d1922237506f
   client_keyshare: 56baa21b552ddd11817394968e88bee9d1e48e3594e2dd2ed6d1
   a5196e181515
   server_private_keyshare: b33ccb6bd5f4c25651dc40610e551747be43bc7e414c
   5ef38aa4c84f55de7c0c
   client_private_keyshare: 0259d333ac0b8095ae9fcceb2ce8e4436fc6add06ac6
   a2a0dccb9b1c22cd0a04
   blind_registration: f41b74572bcc69b51e2c772b39bae02d8944f9f63572cc870
   01e0eb56efbbd0e
   blind_login: edd199cc08f2e471ec9c0331619a9d1c7c7f24f59b1eb1faf9d2a460
   b39c820d
   oprf_key: e14722c2828ebeec94ba102404b81a5035a74fb15cf9ca2fc922866c4c3
   29e0a
   fake_client_public_key: b283aec9100782a5cd140e40f274a9bf1e400c7259e65
   31f8617fa74f2e6bd64
   fake_masking_nonce: fc80240b0e44ae352f59a2f480832db962bd6fc0a61e702ed
   f0f9741490c6f0a
   fake_masking_key: 72a5b3e9098e8263f37dea986a921e9864405ed614aa8d5a418
   b130dafb6513ad917000c83c70199f3202b928f355704e3a25dc7c409e59b33dfdccd
   2b7c4a86

C.6.3.  Intermediate Values

   client_public_key: 02c688b546cce19c80488093e83fade934702ff411f73476cd
   d676657034ee39
   auth_key: 852fa61d368e6d400796e53cc4d2daf046ac2b2afedcdfd732ebdfafc5e
   13a5f1fe6321d5dbf61524bd42f481500282fca27e0c839a710e7854155b476824588
   randomized_pwd: 60a577db41d120c7c6a93264eb24b8f14bc9148ea7e734f6b1eef
   44a3aa08a7480764036d28b8436ad7864c59b7e7f53f6b463bdd55fd8a4448dffdad3
   23a8f3
   envelope: 072d4eccf379adfb08f7f8ec28aadd14a78b68466e51a251d13299f10df
   285950bf56df0e2a2a15df9094bc3e4dd4a9557af3e7c96a47eb4681b3418270d1957
   ce98b8dc27d3fa1de039a9f8af98030ebb79144af7cfde0fa2dc061dfb23fc34d9b2b
   105dde6552b17f4e208e0b3bda08d9a86612bed39e839890b18c4179172
   handshake_secret: c21f50e99d854abaf566beb34190b05fdc7a542841cf40e740f
   83959eb734a57e0005c258ae105c79e928f11437835b9f95209388c757a1d8fb76f7a
   d4345310
   server_mac_key: 02da160ae6ad8614816550ea65075d01d1a79f9880eb04769802f
   c0a6198fa62dabecce40fd1e51541729e743ff42be402aaf9f0fa1614603d9ddcf2d6
   2d3727
   client_mac_key: 351db5480f04192b0ddfd5387045920fa0f72ee287eda8782be70
   c0722c628952cc25a7de126f9e392ef80416c6431a8a67246e89dfb40f6dbf7c925fd
   693f26
   fake_server_mac_key: 044e9fe7f324bb6e6b7a89eb2f338b6f4512e5eed3085aa4
   430fc6d2460f59070055970ee1d785a761cf522168c32d7622ff18d136f373b7a1401
   50c6337bde7
   fake_client_mac_key: 5b8aac04e6a0b7787a67959aa2021ea5805a20173412a115
   4ce4f151262db037ede43ea51e8d40ff7c777fd07d699c9dbaa16e884f2aad30e9fa2
   4f9a39a48b3
   fake_handshake_secret: 82894970fc3d2c5c9fe60c83480d078e529a55be4ccaa5
   acc834b7b2bc1bd25a7f0cf41471693e2cdbac58cb460c510a393184dbcec7b8f1515
   22205a1558a18

C.6.4.  Output Values

   registration_request: 4af0690a72521312e7626b82ead90a760f9d7705544e67c
   1a1d980e5e81ef513
   registration_response: ca961b845e9a9396564e120e37e327960d59ce421ab146
   c4dcfa87a89bb80c78c8f1aa3505a35c276fd5e490d338dbbe51f762bc553b3b71e93
   8d3ff57d97d4a
   registration_upload: 02c688b546cce19c80488093e83fade934702ff411f73476
   cdd676657034ee39f0291a951ec6190a9fdfcd52856a368a98e504076ab54a915ebd6
   a6a7a728c215e1ab7ca134c3408fe7e95e01884a09197adddd4ea7f1cbb2cef425529
   109ec3072d4eccf379adfb08f7f8ec28aadd14a78b68466e51a251d13299f10df2859
   50bf56df0e2a2a15df9094bc3e4dd4a9557af3e7c96a47eb4681b3418270d1957ce98
   b8dc27d3fa1de039a9f8af98030ebb79144af7cfde0fa2dc061dfb23fc34d9b2b105d
   de6552b17f4e208e0b3bda08d9a86612bed39e839890b18c4179172
   KE1: ee8dc4d7ab398f87eecd9b6042f373369e9c1677d40c2e675ed50cc13ea2676c
   679eb9edc4b8943b0ffbe09577ecdb625726cb333292ebc7c8a8c933f0fc980056baa
   21b552ddd11817394968e88bee9d1e48e3594e2dd2ed6d1a5196e181515
   KE2: e0a050bd009a9f2a97d75a4bf660f8fe7fefcf656980e78aa249a2d358339c01
   8d3346ca21d8a6439465aea2b4b54c1d109bc5ea6819cd5cca28ea3ed382a1555700d
   bcc94f0b4a48c7c3d65ca850269f0cedfee11cb4a0d2438eb46dd42954515c89d014a
   7cb8daffec3c912ecd8a57b49d6dc99bb8af6fc7b71d4ee4ffff19d479c0865e356a2
   ec5e530c029a8c5b49471e18834b9b9fc4cbc651be7c36a38353ee6b3219b448a35fa
   6933ffcb701515fdb6ea36faafbe887bc42d88655527d2e76c70f0b8cbd77460f6432
   6c61f69b18b966226605f56165bc020926b279aad275c32713d314a14cd58a6466cfb
   980f9a2604c25d83d1a98a38717e97bfdedc2e6e45d4138be457e0c1ae504de254409
   22f5d127574282b7fd1922237506fba36873ac78ec544760d34cd563da64a8bd2da09
   eafabc59e755c1193c398e2399c93aa8a33d9e8d7484dd407e19ab4a0f7cc2a8e802b
   62e21112bb32adf22ff
   fake_KE2: ee0439579f0672bb6918c2cf12e4b412b18395493935e6de1de6365ad3c
   7765afc80240b0e44ae352f59a2f480832db962bd6fc0a61e702edf0f9741490c6f0a
   0fb4f63494f6d410e1dbb72e557adcf9d689f8285f438c6aed7960156fa64b6cb7126
   bafb5c8b31aeaf853a83ed828862d254d88dbcc705d2dabc3cf1a2530902b4a62ab6a
   1c375211f2e13d0d582a27bd30f52384b9b9dca4d3e331b855ba3e5cd805d24e7b9be
   9a713f87c8e13c5f049323273ec0653836f99e8d4e31f022bcb3c9efd5180a81a0f92
   dc9fb33c9e019202cbb6664054e3ead4e41d7a7adc5ead275c32713d314a14cd58a64
   66cfb980f9a2604c25d83d1a98a38717e97bfdedc2e6e45d4138be457e0c1ae504de2
   5440922f5d127574282b7fd1922237506f22cb3b39b3d41e7b4c232fdf6e3c4ea4194
   921a1c3d334a8cbb3c8d22434afe53c3178c6b2451a3356b27a03490228852968750e
   8c3226e4a9ee30a360ade8fd
   KE3: d609b1348589f242601e00430dd5507f20ecdc3f0ba633ae535f1aa5ea25abf9
   6744becf1ebc7b5c6949baedcaeb147b2c3779f1aa74826f57a112b9639bdd4b
   export_key: 3469dded1ae307c82b95d2d1a90c9fd2a681fc4c13db48ce14192bceb
   c4a7266590c9fd5433ed75e0f8026a0f5c172a0162b16debd41c117faabde42cd8092
   b9
   session_key: b1932d130b1287cadfc33beefad8a5d3d26b30cd84a13c06490d065d
   c1056ab6b5cc147df5fe0c273b2f7d0e728655e71a33ad76773e0d69ddc13217d4019
   5b1

C.7.  OPAQUE-3DH Test Vector 7

C.7.1.  Configuration

   OPRF: 0003
   Hash: SHA256
   MHF: Identity
   KDF: HKDF-SHA256
   MAC: HMAC-SHA256
   EnvelopeMode: 02
   Group: P256_XMD:SHA-256_SSWU_RO_
   Context: 4f50415155452d504f43
   Nh: 32
   Npk: 33
   Nsk: 32
   Nm: 32
   Nx: 32
   Nok: 32

C.7.2.  Input Values

   oprf_seed: 2cdaefac7e1d665da7cc705485b75a3514b967a3c5aa4b15139623bce3
   b7ba2f
   credential_identifier: 31323334
   password: 436f7272656374486f72736542617474657279537461706c65
   envelope_nonce: d940f09508cfe0813c8142ce215e24e7ad7e2d929961c54691525
   129234734d4
   masking_nonce: 2781de00617e568b14b7235cc1189265811ea354031ea39b62e31a
   104f181c01
   client_private_key: de622464f00e607813de02e1784fa9f7d6e3b7bc8c195bae8
   ac677e7bbd1938d
   server_private_key: 6bdcc891568226adab56bf02dd0ea39034488bc2624456399
   4473ca960143fe3
   server_public_key: 0288c05a830584dbb0def233ee57203a014a348fe3cd90625a
   5c3f43ad9c96642e
   server_nonce: 2cc8d050cb0b6deffed2aaf0f46932eea7dceaadb46ccd73f36729b
   cc578bd69
   client_nonce: d3cb00535339fe4063c7ba5506a990c243a2b5c77b06848a0be9a05
   68c252fb0
   server_keyshare: 03e14440fe69f29a3528a4e134331df007e426803831e9dfa090
   5f6fb575b3d088
   client_keyshare: 02d29ed78ad76acd4546281bf847cb043f2bbd57f1037cf0106e
   417f6e52252c76
   server_private_keyshare: 0cdbf092034c00451ccdc6e17a86e0dbe47044226f89
   bafe7eaa7d00248da1a0
   client_private_keyshare: 1e2cc703026e6fb6e3e49a6ef2275cb65bf8d1d30099
   48a4ffa09d1ac3bcc983
   blind_registration: 7a7480a8a64a166e1cb724f59c39f93a802f7f703dadd876c
   68c15bf92070233
   blind_login: 80e5d77cb1251697926e43a66114fbe336f8b371707e75f955933a8c
   7e4667bb
   oprf_key: f54d0b19a8f016cb8b57fb419205e03721717b6fff2505f5fa6cd0a339a
   ae10a

C.7.3.  Intermediate Values

   client_public_key: 020aa6b753fc23bc5682e46e9dfefa55ff7755b0ee65f5d2a3
   1dcbb83e2e116db9
   auth_key: f4588fdafb5d67a2e86daaea618e9d61224cf9c23e4f094831791bf2b78
   97d35
   randomized_pwd: ec5ea982ddce1d877845b33bacc457befcd92aaa9970e5aad4147
   03bc84d154a
   envelope: d940f09508cfe0813c8142ce215e24e7ad7e2d929961c54691525129234
   734d4d655883a1c6691a0845b0a6d62b0a281531a44ea7837750dfa9de1a07f89653c
   cc66c186f589624eed941591bcb7a4fec26c23d7686ef1f038fd9073d63be356
   handshake_secret: 7cee52a030e17fe71c135a2a2dc8163695625d093023b708b54
   f9702c5c4b005
   server_mac_key: b2968e7207e49cca55dc296cee2f09eca8d96b5a66cdb392e1992
   83fceb86951
   client_mac_key: cc9f6ced90e6a7a5fa750d03164093916713afc943401abfc50c8
   91c8707df4a

C.7.4.  Output Values

   registration_request: 032bcd7849d11d367d8291c7313b44d9ce9c90b7e5f31bd
   d925b118ae27315aa1f
   registration_response: 038bc84a153503ba553fbe33f8ebd92b71c294ba362684
   74179c8cd218f336e0f80288c05a830584dbb0def233ee57203a014a348fe3cd90625
   a5c3f43ad9c96642e
   registration_upload: 020aa6b753fc23bc5682e46e9dfefa55ff7755b0ee65f5d2
   a31dcbb83e2e116db9c18160b93ed2c13b52b0dd1730fa8a1e5450f44e3e61de038ae
   aed9ea705fd58d940f09508cfe0813c8142ce215e24e7ad7e2d929961c54691525129
   234734d4d655883a1c6691a0845b0a6d62b0a281531a44ea7837750dfa9de1a07f896
   53ccc66c186f589624eed941591bcb7a4fec26c23d7686ef1f038fd9073d63be356
   KE1: 03bdc4dae4e703edd4d2d5ccaf0b0a1c833bfd791645dbf0f3956ca75f439846
   63d3cb00535339fe4063c7ba5506a990c243a2b5c77b06848a0be9a0568c252fb002d
   29ed78ad76acd4546281bf847cb043f2bbd57f1037cf0106e417f6e52252c76
   KE2: 03fa1e627236c1dc75be75676cf682026bb29b341490b89bc001c66eef1070a7
   c92781de00617e568b14b7235cc1189265811ea354031ea39b62e31a104f181c01075
   158685143351ed5d5724bf2fb04778956f66dc5cca9b67cc719090d14b9ceba3ab8c2
   da423278df10e914793d22d29a21b3e5eb990782f8a0906c95c84c6356185111d16b1
   da98f4d4f3c0562f9d9f09625e9572dee7c751311183cf8eef59d28224ac20b2fc1c8
   58f9717f58537eb0294979182b06e34ca61e38f0235236a82cc8d050cb0b6deffed2a
   af0f46932eea7dceaadb46ccd73f36729bcc578bd6903e14440fe69f29a3528a4e134
   331df007e426803831e9dfa0905f6fb575b3d088add9665f7785bdeba7996b0f0f0ee
   739ceb4e692842468db35d321822fd20b63
   KE3: 76ae4dcf79cb5e473d9b542b38a80f4d1dd9f8a212175b1ede4fe66c9d6f45c1
   export_key: 87ffc345232ffa746ee1b3d0b1d51fa74c57bbf9736b04fa1cb92da98
   7c58254
   session_key: 92d698ad2f45bd74eb29fecbb77f02f11e9044ed47441fe241c91e3c
   8481e464

C.8.  OPAQUE-3DH Test Vector 8

C.8.1.  Configuration

   OPRF: 0003
   Hash: SHA256
   MHF: Identity
   KDF: HKDF-SHA256
   MAC: HMAC-SHA256
   EnvelopeMode: 02
   Group: P256_XMD:SHA-256_SSWU_RO_
   Context: 4f50415155452d504f43
   Nh: 32
   Npk: 33
   Nsk: 32
   Nm: 32
   Nx: 32
   Nok: 32

C.8.2.  Input Values

   client_identity: 616c696365
   server_identity: 626f62
   oprf_seed: 82f3545f2170e6f1c5b85768620773b77ed0c5b9a872e01f13d6a1ba61
   bc6980
   credential_identifier: 31323334
   password: 436f7272656374486f72736542617474657279537461706c65
   envelope_nonce: f0751e2ad9072995a21497528c25c8924c1fc3052f5a89e112c1a
   eee8e67de0a
   masking_nonce: e36bfeaba4c2b939addb8c5d93ac1022e67d606d76e58712a56404
   95a63ad857
   client_private_key: 6aa4943d04ca38392e96fb8c05603c1acb64ea417c0dabaab
   858a5f9da046d4b
   server_private_key: 09fe10cc1a36b0ec93d1fb0146ac2ae11603d9343386bb0c6
   0648f1043aa9964
   server_public_key: 02b0f0f5dac179cfb5a859a6e59d4a2199ceaf6e9d9e97822c
   05b73ffefa04dcb4
   server_nonce: b00c53f21f3fa17ac31d2bbfb914db804a09ffafd1efd97b3b97c34
   cd2efade2
   client_nonce: d3258b3c30408051de122f0df544cad0a756c1c173a349b7cffee6b
   adf2c522c
   server_keyshare: 031f84ea610c3f20e4a4a5d816ac046ede9eb6acc786a6e37563
   1731d05aa5d0bf
   client_keyshare: 02a27fc1948f2d0333803dcd4ff183db6839e3b308832594f02c
   6d4ed303cbbfb4
   server_private_keyshare: f81ea880ff9fde936694165214047e33b08b68638282
   0021a7d32ad3cb8ff610
   client_private_keyshare: b6c151300704c0fbac16363edbb8730c02698e90da9a
   1b7c5f2bbef56212b238
   blind_registration: bf5b53f76c003f113f2ffa3bde6f99b0e11fec8da71b1adea
   0aaea23107c6cb0
   blind_login: cb83943cd5d9e31978dd8225e363726393f5baadebadda45447a5790
   82d1afc0
   oprf_key: a7619f7df37d3ae4903d2a99f35a75367e04cb574e0edc5e3d986d9755d
   9c484
   fake_client_public_key: 02652fdee03126eb1401886e5adacf2c18c37c646b0ff
   1b59ac0efaf08c5d00b79
   fake_masking_nonce: 3c3a8de8a9bc462ad1dedaf979926b4fec3acf87038a5967e
   363ee6a9fa76d6f
   fake_masking_key: c5671e81034ead615ce096fc0e6b97ef90ea8cedbada0e12952
   33ba417790ed8

C.8.3.  Intermediate Values

   client_public_key: 0265122b2cac45b39ab448a00d44880567cd1f427411b6b235
   eeedb22883a7132c
   auth_key: 45e8fe6fa6a960c7751063f11ceac932a55406d2799aaf20cf1560764f5
   b3e3a
   randomized_pwd: 36518d8700fde1f4b9b98da50071b6d6692d2564eb0c7f5ac5629
   35bc056f2ff
   envelope: f0751e2ad9072995a21497528c25c8924c1fc3052f5a89e112c1aeee8e6
   7de0aee71ce672f3c5c1d633ffbda749767c78f5323586e14a9706d9608e1033c3d17
   9afe0609d087432cb7f3290cc767790a9db1b8b579b5354598b5b68a7b032d41
   handshake_secret: 2e209d26beaf0a616dd5b0aaaaab1ddb3fd6c1ff61647729812
   5a7fa02d5aca5
   server_mac_key: 176089dc738f88a6a6e5a70721250ce3a92bed5096e3306dcb246
   05538ed008e
   client_mac_key: 496b3f044c4302ecb2a146ec5b7e1ed92037c738df14a1e0792ca
   ac5ddcfa222
   fake_server_mac_key: 6025c814a62c119f6da59c7d88976143abc90fe1fde465aa
   9256b44ddbe51200
   fake_client_mac_key: 1bcdd1e6ef656915d1f7956164e0f362c26f999e17d4af13
   b490ee50231cb864
   fake_handshake_secret: 8a626023b6824c3aedb3c7a823db3e0d185aa926a1bde3
   c3545f3ac66f3b87e2

C.8.4.  Output Values

   registration_request: 022abe33c33255edcc5b36c481b6f722aba49051ff73576
   ef13f1068cf822029cf
   registration_response: 03445a17730f355102e6f9ccaf0efd5623e792afb9870d
   5144e5d97de8d998602e02b0f0f5dac179cfb5a859a6e59d4a2199ceaf6e9d9e97822
   c05b73ffefa04dcb4
   registration_upload: 0265122b2cac45b39ab448a00d44880567cd1f427411b6b2
   35eeedb22883a7132ced20c978860a401117bec3917d6659b55bfa8ed8f97aeea00d8
   50d21eef741fbf0751e2ad9072995a21497528c25c8924c1fc3052f5a89e112c1aeee
   8e67de0aee71ce672f3c5c1d633ffbda749767c78f5323586e14a9706d9608e1033c3
   d179afe0609d087432cb7f3290cc767790a9db1b8b579b5354598b5b68a7b032d41
   KE1: 03f786425ffe02192cdf8d4d6812397818594cbeac4065286835afb35d60b984
   dad3258b3c30408051de122f0df544cad0a756c1c173a349b7cffee6badf2c522c02a
   27fc1948f2d0333803dcd4ff183db6839e3b308832594f02c6d4ed303cbbfb4
   KE2: 038189b5ee263cb7ac41cfe5d472399e291cc1e9b4c9cc0a747108847efea2f5
   89e36bfeaba4c2b939addb8c5d93ac1022e67d606d76e58712a5640495a63ad857db9
   f2e3eb5b59a859d975362d39f0850c6e05a328e031b6883d8386eaf3cbb4c6491e002
   68795ed78f3388cde2c3d454ebba694b6b135591eeb3afbba6e862ea01d66985e7ca6
   e88d3023e8a132d5aff79470e9b6693d4cbc7d650a0eb0f681cf8b44fd880d516fa60
   2ce9cf8c0578dae951661cf3d6c6536cab8c26efc33af43ab00c53f21f3fa17ac31d2
   bbfb914db804a09ffafd1efd97b3b97c34cd2efade2031f84ea610c3f20e4a4a5d816
   ac046ede9eb6acc786a6e375631731d05aa5d0bfc33a0e139d7e489cb70f43edf1043
   72ea3722b91157d905770ef63cb25d9267b
   fake_KE2: 03de200a920d282d1d94ef79f02ec3194d2e02dcac1d1d8cbd12e05e6f0
   398669d3c3a8de8a9bc462ad1dedaf979926b4fec3acf87038a5967e363ee6a9fa76d
   6fa8bcdbc8af3576011232c3ff9e76b34646fcb24acd2f2ab37d10210371d0c41b822
   0c8d29e1af2a9a5d61f79f0776d6ec0c97cc522b44d892c3f3e32d8522673732d9da2
   b8545b9b81c65f2d88cfffa11fb0d54aaebcf8fabef1328cb90b9ef80a81ba3631623
   8404068e312adbfa135aa515a7c78e01cdcab77df58237b1c7b37b00c53f21f3fa17a
   c31d2bbfb914db804a09ffafd1efd97b3b97c34cd2efade2031f84ea610c3f20e4a4a
   5d816ac046ede9eb6acc786a6e375631731d05aa5d0bf1860b5d5c54de855e2b88797
   b090b4bab9bc1d94dd44938239e74dd6565bd3f7
   KE3: 10e1619c67c326c3c8c590e8b4623f73ae0a183631b07dc8e19741d3ecf6a279
   export_key: cfcef790840d97adee0128e5ebf3b98817fc7f192e6b925848d1cbca6
   eff16f5
   session_key: 6c3a0e2bb103ebaf6d199c22b71fd01244be0af9adac831252cebad7
   ea3361e0

Authors' Addresses

   Hugo Krawczyk
   Algorand Foundation

   Email: hugokraw@gmail.com


   Daniel Bourdrez

   Email: dan@bytema.re


   Kevin Lewi
   Novi Research

   Email: lewi.kevin.k@gmail.com


   Christopher A. Wood
   Cloudflare

   Email: caw@heapingbits.net
